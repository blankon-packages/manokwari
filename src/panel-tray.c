/* panel-tray.c generated by valac 0.26.1, the Vala compiler
 * generated from panel-tray.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gtk/gtkx.h>
#include <gdk/gdk.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <gdk/gdkx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define TYPE_PANEL_TRAY (panel_tray_get_type ())
#define PANEL_TRAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_TRAY, PanelTray))
#define PANEL_TRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_TRAY, PanelTrayClass))
#define IS_PANEL_TRAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_TRAY))
#define IS_PANEL_TRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_TRAY))
#define PANEL_TRAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_TRAY, PanelTrayClass))

typedef struct _PanelTray PanelTray;
typedef struct _PanelTrayClass PanelTrayClass;
typedef struct _PanelTrayPrivate PanelTrayPrivate;

#define PANEL_TRAY_TYPE_MESSAGE (panel_tray_message_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block4Data Block4Data;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _PanelTray {
	GtkHBox parent_instance;
	PanelTrayPrivate * priv;
};

struct _PanelTrayClass {
	GtkHBoxClass parent_class;
};

struct _PanelTrayPrivate {
	GtkInvisible* invisible;
};

typedef enum  {
	PANEL_TRAY_MESSAGE_REQUEST_DOCK,
	PANEL_TRAY_MESSAGE_BEGIN,
	PANEL_TRAY_MESSAGE_CANCEL
} PanelTrayMessage;

struct _Block4Data {
	int _ref_count_;
	PanelTray* self;
	GtkSocket* w;
};


static gpointer panel_tray_parent_class = NULL;

GType panel_tray_get_type (void) G_GNUC_CONST;
#define PANEL_TRAY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_TRAY, PanelTrayPrivate))
enum  {
	PANEL_TRAY_DUMMY_PROPERTY
};
static GType panel_tray_message_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void panel_tray_add_client (PanelTray* self, glong xid);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static gboolean __lambda31_ (Block4Data* _data4_);
static gboolean ___lambda31__gtk_socket_plug_removed (GtkSocket* _sender, gpointer self);
static GdkFilterReturn panel_tray_event_filter (PanelTray* self, GdkXEvent* xev, GdkEvent* event);
static gboolean panel_tray_setup_selection (PanelTray* self);
static GdkFilterReturn _panel_tray_event_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self);
PanelTray* panel_tray_new (void);
PanelTray* panel_tray_construct (GType object_type);
static gboolean panel_tray_real_draw (GtkWidget* base, cairo_t* cr);
static void panel_tray_finalize (GObject* obj);


static GType panel_tray_message_get_type (void) {
	static volatile gsize panel_tray_message_type_id__volatile = 0;
	if (g_once_init_enter (&panel_tray_message_type_id__volatile)) {
		static const GEnumValue values[] = {{PANEL_TRAY_MESSAGE_REQUEST_DOCK, "PANEL_TRAY_MESSAGE_REQUEST_DOCK", "request-dock"}, {PANEL_TRAY_MESSAGE_BEGIN, "PANEL_TRAY_MESSAGE_BEGIN", "begin"}, {PANEL_TRAY_MESSAGE_CANCEL, "PANEL_TRAY_MESSAGE_CANCEL", "cancel"}, {0, NULL, NULL}};
		GType panel_tray_message_type_id;
		panel_tray_message_type_id = g_enum_register_static ("PanelTrayMessage", values);
		g_once_init_leave (&panel_tray_message_type_id__volatile, panel_tray_message_type_id);
	}
	return panel_tray_message_type_id__volatile;
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		PanelTray* self;
		self = _data4_->self;
		_g_object_unref0 (_data4_->w);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static gboolean __lambda31_ (Block4Data* _data4_) {
	PanelTray* self;
	gboolean result = FALSE;
	GtkSocket* _tmp0_ = NULL;
	self = _data4_->self;
	_tmp0_ = _data4_->w;
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
	gtk_widget_show_all ((GtkWidget*) self);
	result = TRUE;
	return result;
}


static gboolean ___lambda31__gtk_socket_plug_removed (GtkSocket* _sender, gpointer self) {
	gboolean result;
	result = __lambda31_ (self);
	return result;
}


static void panel_tray_add_client (PanelTray* self, glong xid) {
	Block4Data* _data4_;
	GList* _tmp0_ = NULL;
	GtkSocket* _tmp7_ = NULL;
	GtkSocket* _tmp8_ = NULL;
	GtkSocket* _tmp9_ = NULL;
	GtkSocket* _tmp10_ = NULL;
	glong _tmp11_ = 0L;
	GtkSocket* _tmp12_ = NULL;
	g_return_if_fail (self != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = gtk_container_get_children ((GtkContainer*) self);
	{
		GList* w_collection = NULL;
		GList* w_it = NULL;
		w_collection = _tmp0_;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			GtkWidget* w = NULL;
			w = (GtkWidget*) w_it->data;
			{
				GtkSocket* socket = NULL;
				GtkWidget* _tmp1_ = NULL;
				GtkSocket* _tmp2_ = NULL;
				_tmp1_ = w;
				socket = G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_SOCKET) ? ((GtkSocket*) _tmp1_) : NULL;
				_tmp2_ = socket;
				if (_tmp2_ != NULL) {
					glong id = 0L;
					GtkSocket* _tmp3_ = NULL;
					GtkWindow* _tmp4_ = NULL;
					glong _tmp5_ = 0L;
					glong _tmp6_ = 0L;
					_tmp3_ = socket;
					_tmp4_ = gtk_socket_get_id (_tmp3_);
					id = (glong) _tmp4_;
					_tmp5_ = id;
					_tmp6_ = xid;
					if (_tmp5_ == _tmp6_) {
						_g_list_free0 (w_collection);
						block4_data_unref (_data4_);
						_data4_ = NULL;
						return;
					}
				}
			}
		}
		_g_list_free0 (w_collection);
	}
	_tmp7_ = (GtkSocket*) gtk_socket_new ();
	g_object_ref_sink (_tmp7_);
	_data4_->w = _tmp7_;
	_tmp8_ = _data4_->w;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp8_, FALSE, FALSE, (guint) 0);
	_tmp9_ = _data4_->w;
	gtk_widget_show ((GtkWidget*) _tmp9_);
	_tmp10_ = _data4_->w;
	_tmp11_ = xid;
	gtk_socket_add_id (_tmp10_, _tmp11_);
	g_signal_emit_by_name (self, "new-item-added");
	gtk_widget_hide ((GtkWidget*) self);
	gtk_widget_show_all ((GtkWidget*) self);
	_tmp12_ = _data4_->w;
	g_signal_connect_data (_tmp12_, "plug-removed", (GCallback) ___lambda31__gtk_socket_plug_removed, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	block4_data_unref (_data4_);
	_data4_ = NULL;
}


static GdkFilterReturn panel_tray_event_filter (PanelTray* self, GdkXEvent* xev, GdkEvent* event) {
	GdkFilterReturn result = 0;
	Display* display = NULL;
	Display* _tmp0_ = NULL;
	GdkFilterReturn return_value = 0;
	void* pointer = NULL;
	XEvent* xevent = NULL;
	void* _tmp1_ = NULL;
	XEvent* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (xev != NULL, 0);
	g_return_val_if_fail (event != NULL, 0);
	_tmp0_ = gdk_x11_get_default_xdisplay ();
	display = _tmp0_;
	return_value = GDK_FILTER_CONTINUE;
	pointer = xev;
	_tmp1_ = pointer;
	xevent = (XEvent*) _tmp1_;
	_tmp2_ = xevent;
	_tmp3_ = (*_tmp2_).type;
	if (_tmp3_ == ((gint) ClientMessage)) {
		XEvent* _tmp4_ = NULL;
		XClientMessageEvent _tmp5_ = {0};
		Atom _tmp6_ = {0};
		Display* _tmp7_ = NULL;
		Atom _tmp8_ = {0};
		_tmp4_ = xevent;
		_tmp5_ = (*_tmp4_).xclient;
		_tmp6_ = _tmp5_.message_type;
		_tmp7_ = display;
		_tmp8_ = XInternAtom (_tmp7_, "_NET_SYSTEM_TRAY_OPCODE", FALSE);
		if (_tmp6_ == _tmp8_) {
			XEvent* _tmp9_ = NULL;
			XClientMessageEvent _tmp10_ = {0};
			glong* _tmp11_ = NULL;
			gint _tmp11__length1 = 0;
			glong _tmp12_ = 0L;
			_tmp9_ = xevent;
			_tmp10_ = (*_tmp9_).xclient;
			_tmp11_ = _tmp10_.data.l;
			_tmp11__length1 = -1;
			_tmp12_ = _tmp11_[1];
			if (_tmp12_ == ((glong) PANEL_TRAY_MESSAGE_REQUEST_DOCK)) {
				XEvent* _tmp13_ = NULL;
				XClientMessageEvent _tmp14_ = {0};
				glong* _tmp15_ = NULL;
				gint _tmp15__length1 = 0;
				glong _tmp16_ = 0L;
				_tmp13_ = xevent;
				_tmp14_ = (*_tmp13_).xclient;
				_tmp15_ = _tmp14_.data.l;
				_tmp15__length1 = -1;
				_tmp16_ = _tmp15_[2];
				panel_tray_add_client (self, _tmp16_);
				result = GDK_FILTER_REMOVE;
				return result;
			}
		} else {
			FILE* _tmp17_ = NULL;
			_tmp17_ = stdout;
			fprintf (_tmp17_, "req: d\n");
		}
	}
	result = return_value;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GdkFilterReturn _panel_tray_event_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self) {
	GdkFilterReturn result;
	result = panel_tray_event_filter ((PanelTray*) self, xevent, event);
	return result;
}


static gboolean panel_tray_setup_selection (PanelTray* self) {
	gboolean result = FALSE;
	Display* display = NULL;
	Display* _tmp0_ = NULL;
	GdkScreen* screen = NULL;
	GdkScreen* _tmp1_ = NULL;
	GdkScreen* _tmp2_ = NULL;
	GdkAtom atom = {0};
	GdkScreen* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	GdkAtom _tmp7_ = {0};
	GdkAtom _tmp8_ = {0};
	GdkWindow* owner = NULL;
	GdkDisplay* _tmp9_ = NULL;
	GdkAtom _tmp10_ = {0};
	GdkWindow* _tmp11_ = NULL;
	GdkWindow* _tmp12_ = NULL;
	GdkWindow* _tmp13_ = NULL;
	GdkDisplay* _tmp15_ = NULL;
	GtkInvisible* _tmp16_ = NULL;
	GdkWindow* _tmp17_ = NULL;
	GdkAtom _tmp18_ = {0};
	gboolean _tmp19_ = FALSE;
	glong xid = 0L;
	GtkInvisible* _tmp21_ = NULL;
	GdkWindow* _tmp22_ = NULL;
	Window _tmp23_ = 0;
	XClientMessageEvent event = {0};
	Display* _tmp24_ = NULL;
	GdkScreen* _tmp25_ = NULL;
	gint _tmp26_ = 0;
	Window _tmp27_ = 0;
	Display* _tmp28_ = NULL;
	Atom _tmp29_ = {0};
	glong _tmp30_ = 0L;
	Display* _tmp31_ = NULL;
	GdkScreen* _tmp32_ = NULL;
	gint _tmp33_ = 0;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_ = NULL;
	Atom _tmp36_ = {0};
	glong _tmp37_ = 0L;
	glong _tmp38_ = 0L;
	glong _tmp39_ = 0L;
	glong _tmp40_ = 0L;
	glong _tmp41_ = 0L;
	Display* _tmp42_ = NULL;
	Display* _tmp43_ = NULL;
	GdkScreen* _tmp44_ = NULL;
	gint _tmp45_ = 0;
	Window _tmp46_ = 0;
	gulong data[1] = {0};
	gulong _tmp47_[1] = {0};
	Display* _tmp48_ = NULL;
	glong _tmp49_ = 0L;
	Display* _tmp50_ = NULL;
	Atom _tmp51_ = {0};
	GtkInvisible* _tmp52_ = NULL;
	GdkWindow* _tmp53_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gdk_x11_get_default_xdisplay ();
	display = _tmp0_;
	_tmp1_ = gtk_widget_get_screen ((GtkWidget*) self);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	screen = _tmp2_;
	_tmp3_ = screen;
	_tmp4_ = gdk_screen_get_number (_tmp3_);
	_tmp5_ = g_strdup_printf ("_NET_SYSTEM_TRAY_S%d", _tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = gdk_atom_intern (_tmp6_, FALSE);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	atom = _tmp8_;
	_tmp9_ = gtk_widget_get_display ((GtkWidget*) self);
	_tmp10_ = atom;
	_tmp11_ = gdk_selection_owner_get_for_display (_tmp9_, _tmp10_);
	_tmp12_ = _g_object_ref0 (_tmp11_);
	owner = _tmp12_;
	_tmp13_ = owner;
	if (_tmp13_ != NULL) {
		FILE* _tmp14_ = NULL;
		_tmp14_ = stdout;
		fprintf (_tmp14_, "Tray is already owned by someone else.\n");
		result = FALSE;
		_g_object_unref0 (owner);
		_g_object_unref0 (screen);
		return result;
	}
	_tmp15_ = gtk_widget_get_display ((GtkWidget*) self);
	_tmp16_ = self->priv->invisible;
	_tmp17_ = gtk_widget_get_window ((GtkWidget*) _tmp16_);
	_tmp18_ = atom;
	_tmp19_ = gdk_selection_owner_set_for_display (_tmp15_, _tmp17_, _tmp18_, (guint32) GDK_CURRENT_TIME, TRUE);
	if (_tmp19_ == FALSE) {
		FILE* _tmp20_ = NULL;
		_tmp20_ = stdout;
		fprintf (_tmp20_, "Unable to claim Tray.\n");
		result = FALSE;
		_g_object_unref0 (owner);
		_g_object_unref0 (screen);
		return result;
	}
	_tmp21_ = self->priv->invisible;
	_tmp22_ = gtk_widget_get_window ((GtkWidget*) _tmp21_);
	_tmp23_ = gdk_x11_window_get_xid (_tmp22_);
	xid = (glong) _tmp23_;
	memset (&event, 0, sizeof (XClientMessageEvent));
	event.type = (gint) ClientMessage;
	_tmp24_ = display;
	_tmp25_ = screen;
	_tmp26_ = gdk_screen_get_number (_tmp25_);
	_tmp27_ = XRootWindow (_tmp24_, _tmp26_);
	event.window = _tmp27_;
	_tmp28_ = display;
	_tmp29_ = XInternAtom (_tmp28_, "MANAGER", FALSE);
	event.message_type = _tmp29_;
	event.format = 32;
	event.data.l[0] = (glong) GDK_CURRENT_TIME;
	_tmp30_ = event.data.l[0];
	_tmp31_ = display;
	_tmp32_ = screen;
	_tmp33_ = gdk_screen_get_number (_tmp32_);
	_tmp34_ = g_strdup_printf ("_NET_SYSTEM_TRAY_S%d", _tmp33_);
	_tmp35_ = _tmp34_;
	_tmp36_ = XInternAtom (_tmp31_, _tmp35_, FALSE);
	event.data.l[1] = (glong) _tmp36_;
	_tmp37_ = event.data.l[1];
	_g_free0 (_tmp35_);
	_tmp38_ = xid;
	event.data.l[2] = _tmp38_;
	_tmp39_ = event.data.l[2];
	event.data.l[3] = (glong) 0;
	_tmp40_ = event.data.l[3];
	event.data.l[4] = (glong) 0;
	_tmp41_ = event.data.l[4];
	_tmp42_ = display;
	_tmp43_ = display;
	_tmp44_ = screen;
	_tmp45_ = gdk_screen_get_number (_tmp44_);
	_tmp46_ = XRootWindow (_tmp43_, _tmp45_);
	XSendEvent (_tmp42_, _tmp46_, FALSE, (glong) StructureNotifyMask, &event);
	_tmp47_[0] = (gulong) 0;
	memcpy (data, _tmp47_, 1 * sizeof (gulong));
	_tmp48_ = display;
	_tmp49_ = xid;
	_tmp50_ = display;
	_tmp51_ = XInternAtom (_tmp50_, "_NET_SYSTEM_TRAY_ORIENTATION,", FALSE);
	XChangeProperty (_tmp48_, (Window) _tmp49_, _tmp51_, XA_CARDINAL, 32, (gint) PropModeReplace, (guchar*) data, 1);
	_tmp52_ = self->priv->invisible;
	_tmp53_ = gtk_widget_get_window ((GtkWidget*) _tmp52_);
	gdk_window_add_filter (_tmp53_, _panel_tray_event_filter_gdk_filter_func, self);
	result = TRUE;
	 (&event);
	_g_object_unref0 (owner);
	_g_object_unref0 (screen);
	return result;
}


PanelTray* panel_tray_construct (GType object_type) {
	PanelTray * self = NULL;
	GtkInvisible* _tmp0_ = NULL;
	GtkInvisible* _tmp1_ = NULL;
	GtkInvisible* _tmp2_ = NULL;
	GtkDrawingArea* empty = NULL;
	GtkDrawingArea* _tmp3_ = NULL;
	self = (PanelTray*) g_object_new (object_type, NULL);
	_tmp0_ = (GtkInvisible*) gtk_invisible_new ();
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->invisible);
	self->priv->invisible = _tmp0_;
	_tmp1_ = self->priv->invisible;
	gtk_widget_add_events ((GtkWidget*) _tmp1_, (gint) (GDK_PROPERTY_CHANGE_MASK | GDK_STRUCTURE_MASK));
	_tmp2_ = self->priv->invisible;
	gtk_widget_realize ((GtkWidget*) _tmp2_);
	gtk_widget_show ((GtkWidget*) self);
	panel_tray_setup_selection (self);
	_tmp3_ = (GtkDrawingArea*) gtk_drawing_area_new ();
	g_object_ref_sink (_tmp3_);
	empty = _tmp3_;
	gtk_widget_show ((GtkWidget*) empty);
	gtk_widget_set_size_request ((GtkWidget*) empty, 10, 1);
	gtk_box_pack_end ((GtkBox*) self, (GtkWidget*) empty, FALSE, FALSE, (guint) 0);
	_g_object_unref0 (empty);
	return self;
}


PanelTray* panel_tray_new (void) {
	return panel_tray_construct (TYPE_PANEL_TRAY);
}


static gboolean panel_tray_real_draw (GtkWidget* base, cairo_t* cr) {
	PanelTray * self;
	gboolean result = FALSE;
	GtkStyleContext* style = NULL;
	GtkStyleContext* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStateFlags _tmp2_ = 0;
	cairo_t* _tmp3_ = NULL;
	GdkWindow* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	GdkWindow* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	cairo_t* _tmp8_ = NULL;
	self = (PanelTray*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style = _tmp1_;
	_tmp2_ = gtk_widget_get_state_flags ((GtkWidget*) self);
	gtk_style_context_set_state (style, _tmp2_);
	_tmp3_ = cr;
	_tmp4_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp5_ = gdk_window_get_width (_tmp4_);
	_tmp6_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp7_ = gdk_window_get_height (_tmp6_);
	gtk_render_background (style, _tmp3_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp5_, (gdouble) _tmp7_);
	_tmp8_ = cr;
	GTK_WIDGET_CLASS (panel_tray_parent_class)->draw ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_HBOX, GtkHBox), _tmp8_);
	result = TRUE;
	_g_object_unref0 (style);
	return result;
}


static void panel_tray_class_init (PanelTrayClass * klass) {
	panel_tray_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelTrayPrivate));
	((GtkWidgetClass *) klass)->draw = panel_tray_real_draw;
	G_OBJECT_CLASS (klass)->finalize = panel_tray_finalize;
	g_signal_new ("new_item_added", TYPE_PANEL_TRAY, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void panel_tray_instance_init (PanelTray * self) {
	self->priv = PANEL_TRAY_GET_PRIVATE (self);
}


static void panel_tray_finalize (GObject* obj) {
	PanelTray * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_TRAY, PanelTray);
	_g_object_unref0 (self->priv->invisible);
	G_OBJECT_CLASS (panel_tray_parent_class)->finalize (obj);
}


GType panel_tray_get_type (void) {
	static volatile gsize panel_tray_type_id__volatile = 0;
	if (g_once_init_enter (&panel_tray_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelTrayClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_tray_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelTray), 0, (GInstanceInitFunc) panel_tray_instance_init, NULL };
		GType panel_tray_type_id;
		panel_tray_type_id = g_type_register_static (GTK_TYPE_HBOX, "PanelTray", &g_define_type_info, 0);
		g_once_init_leave (&panel_tray_type_id__volatile, panel_tray_type_id);
	}
	return panel_tray_type_id__volatile;
}



