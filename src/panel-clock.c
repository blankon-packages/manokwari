/* panel-clock.c generated by valac 0.26.1, the Vala compiler
 * generated from panel-clock.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <pango/pango.h>
#include <time.h>
#include <glib/gi18n-lib.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define TYPE_PANEL_CLOCK (panel_clock_get_type ())
#define PANEL_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_CLOCK, PanelClock))
#define PANEL_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_CLOCK, PanelClockClass))
#define IS_PANEL_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_CLOCK))
#define IS_PANEL_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_CLOCK))
#define PANEL_CLOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_CLOCK, PanelClockClass))

typedef struct _PanelClock PanelClock;
typedef struct _PanelClockClass PanelClockClass;
typedef struct _PanelClockPrivate PanelClockPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _PanelClock {
	GtkLabel parent_instance;
	PanelClockPrivate * priv;
};

struct _PanelClockClass {
	GtkLabelClass parent_class;
};

struct _PanelClockPrivate {
	PangoLayout* pango;
};


static gpointer panel_clock_parent_class = NULL;

GType panel_clock_get_type (void) G_GNUC_CONST;
#define PANEL_CLOCK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_CLOCK, PanelClockPrivate))
enum  {
	PANEL_CLOCK_DUMMY_PROPERTY
};
#define PANEL_CLOCK_MARGIN 10
PanelClock* panel_clock_new (void);
PanelClock* panel_clock_construct (GType object_type);
static gboolean panel_clock_update (PanelClock* self);
static gboolean _panel_clock_update_gsource_func (gpointer self);
static gboolean panel_clock_real_draw (GtkWidget* base, cairo_t* cr);
static void panel_clock_finalize (GObject* obj);


static gboolean _panel_clock_update_gsource_func (gpointer self) {
	gboolean result;
	result = panel_clock_update ((PanelClock*) self);
	return result;
}


PanelClock* panel_clock_construct (GType object_type) {
	PanelClock * self = NULL;
	PangoContext* _tmp0_ = NULL;
	PangoLayout* _tmp1_ = NULL;
	PangoLayout* _tmp2_ = NULL;
	self = (PanelClock*) g_object_new (object_type, NULL);
	_tmp0_ = gtk_widget_get_pango_context ((GtkWidget*) self);
	_tmp1_ = pango_layout_new (_tmp0_);
	_g_object_unref0 (self->priv->pango);
	self->priv->pango = _tmp1_;
	_tmp2_ = self->priv->pango;
	pango_layout_set_alignment (_tmp2_, PANGO_ALIGN_CENTER);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) (1000 * 30), _panel_clock_update_gsource_func, g_object_ref (self), g_object_unref);
	panel_clock_update (self);
	return self;
}


PanelClock* panel_clock_new (void) {
	return panel_clock_construct (TYPE_PANEL_CLOCK);
}


static void g_time_local (time_t time, struct tm* result) {
	struct tm _result_ = {0};
	struct tm _tmp0_ = {0};
	localtime_r (&time, &_tmp0_);
	_result_ = _tmp0_;
	*result = _result_;
	return;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean panel_clock_update (PanelClock* self) {
	gboolean result = FALSE;
	gchar bufferClock[100] = {0};
	struct tm t = {0};
	time_t _tmp0_ = 0;
	struct tm _tmp1_ = {0};
	const gchar* _tmp2_ = NULL;
	GtkStyleContext* style = NULL;
	GtkStyleContext* _tmp3_ = NULL;
	GtkStyleContext* _tmp4_ = NULL;
	PangoLayout* _tmp5_ = NULL;
	GtkStateFlags _tmp6_ = 0;
	PangoFontDescription* _tmp7_ = NULL;
	PangoLayout* _tmp8_ = NULL;
	gint text_w = 0;
	gint text_h = 0;
	PangoLayout* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = time (NULL);
	g_time_local (_tmp0_, &_tmp1_);
	t = _tmp1_;
	_tmp2_ = _ ("%a, %e %b %Y %H:%M");
	strftime (bufferClock, 100, _tmp2_, &t);
	_tmp3_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp4_ = _g_object_ref0 (_tmp3_);
	style = _tmp4_;
	_tmp5_ = self->priv->pango;
	_tmp6_ = gtk_widget_get_state_flags ((GtkWidget*) self);
	_tmp7_ = gtk_style_context_get_font (style, _tmp6_);
	pango_layout_set_font_description (_tmp5_, _tmp7_);
	_tmp8_ = self->priv->pango;
	pango_layout_set_markup (_tmp8_, (const gchar*) bufferClock, -1);
	_tmp9_ = self->priv->pango;
	pango_layout_get_pixel_size (_tmp9_, &_tmp10_, &_tmp11_);
	text_w = _tmp10_;
	text_h = _tmp11_;
	gtk_widget_set_size_request ((GtkWidget*) self, text_w + PANEL_CLOCK_MARGIN, text_h);
	gtk_widget_queue_draw ((GtkWidget*) self);
	result = TRUE;
	_g_object_unref0 (style);
	return result;
}


static gboolean panel_clock_real_draw (GtkWidget* base, cairo_t* cr) {
	PanelClock * self;
	gboolean result = FALSE;
	GtkStyleContext* style = NULL;
	GtkStyleContext* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStateFlags _tmp2_ = 0;
	cairo_t* _tmp3_ = NULL;
	PangoLayout* _tmp4_ = NULL;
	self = (PanelClock*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style = _tmp1_;
	_tmp2_ = gtk_widget_get_state_flags ((GtkWidget*) self);
	gtk_style_context_set_state (style, _tmp2_);
	_tmp3_ = cr;
	_tmp4_ = self->priv->pango;
	gtk_render_layout (style, _tmp3_, (gdouble) (PANEL_CLOCK_MARGIN / 2), (gdouble) 0, _tmp4_);
	result = TRUE;
	_g_object_unref0 (style);
	return result;
}


static void panel_clock_class_init (PanelClockClass * klass) {
	panel_clock_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelClockPrivate));
	((GtkWidgetClass *) klass)->draw = panel_clock_real_draw;
	G_OBJECT_CLASS (klass)->finalize = panel_clock_finalize;
}


static void panel_clock_instance_init (PanelClock * self) {
	self->priv = PANEL_CLOCK_GET_PRIVATE (self);
}


static void panel_clock_finalize (GObject* obj) {
	PanelClock * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_CLOCK, PanelClock);
	_g_object_unref0 (self->priv->pango);
	G_OBJECT_CLASS (panel_clock_parent_class)->finalize (obj);
}


GType panel_clock_get_type (void) {
	static volatile gsize panel_clock_type_id__volatile = 0;
	if (g_once_init_enter (&panel_clock_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelClockClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_clock_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelClock), 0, (GInstanceInitFunc) panel_clock_instance_init, NULL };
		GType panel_clock_type_id;
		panel_clock_type_id = g_type_register_static (GTK_TYPE_LABEL, "PanelClock", &g_define_type_info, 0);
		g_once_init_leave (&panel_clock_type_id__volatile, panel_clock_type_id);
	}
	return panel_clock_type_id__volatile;
}



