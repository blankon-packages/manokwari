/* panel-menu-box.c generated by valac 0.26.1, the Vala compiler
 * generated from panel-menu-box.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <webkit/webkit.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>


#define TYPE_PANEL_ABSTRACT_WINDOW (panel_abstract_window_get_type ())
#define PANEL_ABSTRACT_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_ABSTRACT_WINDOW, PanelAbstractWindow))
#define PANEL_ABSTRACT_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_ABSTRACT_WINDOW, PanelAbstractWindowClass))
#define IS_PANEL_ABSTRACT_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_ABSTRACT_WINDOW))
#define IS_PANEL_ABSTRACT_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_ABSTRACT_WINDOW))
#define PANEL_ABSTRACT_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_ABSTRACT_WINDOW, PanelAbstractWindowClass))

typedef struct _PanelAbstractWindow PanelAbstractWindow;
typedef struct _PanelAbstractWindowClass PanelAbstractWindowClass;
typedef struct _PanelAbstractWindowPrivate PanelAbstractWindowPrivate;

#define TYPE_PANEL_MENU_BOX (panel_menu_box_get_type ())
#define PANEL_MENU_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_MENU_BOX, PanelMenuBox))
#define PANEL_MENU_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_MENU_BOX, PanelMenuBoxClass))
#define IS_PANEL_MENU_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_MENU_BOX))
#define IS_PANEL_MENU_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_MENU_BOX))
#define PANEL_MENU_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_MENU_BOX, PanelMenuBoxClass))

typedef struct _PanelMenuBox PanelMenuBox;
typedef struct _PanelMenuBoxClass PanelMenuBoxClass;
typedef struct _PanelMenuBoxPrivate PanelMenuBoxPrivate;

#define TYPE_PANEL_MENU_HTML (panel_menu_html_get_type ())
#define PANEL_MENU_HTML(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_MENU_HTML, PanelMenuHTML))
#define PANEL_MENU_HTML_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_MENU_HTML, PanelMenuHTMLClass))
#define IS_PANEL_MENU_HTML(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_MENU_HTML))
#define IS_PANEL_MENU_HTML_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_MENU_HTML))
#define PANEL_MENU_HTML_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_MENU_HTML, PanelMenuHTMLClass))

typedef struct _PanelMenuHTML PanelMenuHTML;
typedef struct _PanelMenuHTMLClass PanelMenuHTMLClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _PanelAbstractWindow {
	GtkWindow parent_instance;
	PanelAbstractWindowPrivate * priv;
};

struct _PanelAbstractWindowClass {
	GtkWindowClass parent_class;
};

struct _PanelMenuBox {
	PanelAbstractWindow parent_instance;
	PanelMenuBoxPrivate * priv;
};

struct _PanelMenuBoxClass {
	PanelAbstractWindowClass parent_class;
};

struct _PanelMenuBoxPrivate {
	PanelMenuHTML* view;
};


static gpointer panel_menu_box_parent_class = NULL;

GType panel_abstract_window_get_type (void) G_GNUC_CONST;
GType panel_menu_box_get_type (void) G_GNUC_CONST;
GType panel_menu_html_get_type (void) G_GNUC_CONST;
#define PANEL_MENU_BOX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_MENU_BOX, PanelMenuBoxPrivate))
enum  {
	PANEL_MENU_BOX_DUMMY_PROPERTY
};
#define PANEL_MENU_BOX_COLUMN_WIDTH 260
PanelMenuBox* panel_menu_box_new (void);
PanelMenuBox* panel_menu_box_construct (GType object_type);
PanelAbstractWindow* panel_abstract_window_new (void);
PanelAbstractWindow* panel_abstract_window_construct (GType object_type);
static void panel_menu_box_dismiss (PanelMenuBox* self);
static void _panel_menu_box_dismiss_gd_bus_signal_callback (GDBusConnection* connection, const gchar* sender_name, const gchar* object_path, const gchar* interface_name, const gchar* signal_name, GVariant* parameters, gpointer self);
PanelMenuHTML* panel_menu_html_new (void);
PanelMenuHTML* panel_menu_html_construct (GType object_type);
void panel_screen_move_window (GtkWindow* window, GdkGravity gravity);
void panel_menu_html_start (PanelMenuHTML* self);
static gboolean __lambda70_ (PanelMenuBox* self, GdkEventButton* event);
static gboolean ___lambda70__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static void __lambda71_ (PanelMenuBox* self);
static void ___lambda71__panel_abstract_window_screen_size_changed (PanelAbstractWindow* _sender, gpointer self);
static gboolean __lambda72_ (PanelMenuBox* self);
void utils_grab (GtkWindow* w);
void panel_menu_html_triggerShowAnimation (PanelMenuHTML* self);
static gboolean ___lambda72__gtk_widget_map_event (GtkWidget* _sender, GdkEvent* event, gpointer self);
static gboolean __lambda73_ (PanelMenuBox* self, GdkEventKey* e);
gboolean panel_menu_html_handleEsc (PanelMenuHTML* self);
gboolean utils_print_screen (void);
static gboolean ___lambda73__gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
static void panel_menu_box_real_get_preferred_width (GtkWidget* base, gint* min, gint* max);
static void panel_menu_box_real_get_preferred_height (GtkWidget* base, gint* min, gint* max);
void panel_screen_get_primary_monitor_geometry (GdkRectangle* result);
void utils_ungrab (GtkWindow* w);
void panel_menu_box_try_hide (PanelMenuBox* self);
static gboolean panel_menu_box_real_hide (PanelMenuBox* self);
void panel_menu_html_triggerHideAnimation (PanelMenuHTML* self);
static gboolean _panel_menu_box_real_hide_gsource_func (gpointer self);
static void panel_menu_box_finalize (GObject* obj);


static void _panel_menu_box_dismiss_gd_bus_signal_callback (GDBusConnection* connection, const gchar* sender_name, const gchar* object_path, const gchar* interface_name, const gchar* signal_name, GVariant* parameters, gpointer self) {
	panel_menu_box_dismiss ((PanelMenuBox*) self);
}


static gboolean __lambda70_ (PanelMenuBox* self, GdkEventButton* event) {
	gboolean result = FALSE;
	FILE* _tmp0_ = NULL;
	GdkEventButton _tmp1_ = {0};
	gdouble _tmp2_ = 0.0;
	GdkWindow* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "xxx\n");
	_tmp1_ = *event;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp4_ = gdk_window_get_width (_tmp3_);
	if (_tmp2_ > ((gdouble) _tmp4_)) {
		panel_menu_box_dismiss (self);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda70__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda70_ ((PanelMenuBox*) self, event);
	return result;
}


static void __lambda71_ (PanelMenuBox* self) {
	panel_screen_move_window ((GtkWindow*) self, GDK_GRAVITY_NORTH_WEST);
	gtk_widget_queue_resize ((GtkWidget*) self);
}


static void ___lambda71__panel_abstract_window_screen_size_changed (PanelAbstractWindow* _sender, gpointer self) {
	__lambda71_ ((PanelMenuBox*) self);
}


static gboolean __lambda72_ (PanelMenuBox* self) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_ = NULL;
	PanelMenuHTML* _tmp1_ = NULL;
	g_signal_emit_by_name (self, "shown");
	panel_screen_move_window ((GtkWindow*) self, GDK_GRAVITY_NORTH_WEST);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_window_raise (_tmp0_);
	utils_grab ((GtkWindow*) self);
	_tmp1_ = self->priv->view;
	panel_menu_html_triggerShowAnimation (_tmp1_);
	result = TRUE;
	return result;
}


static gboolean ___lambda72__gtk_widget_map_event (GtkWidget* _sender, GdkEvent* event, gpointer self) {
	gboolean result;
	result = __lambda72_ ((PanelMenuBox*) self);
	return result;
}


static gboolean __lambda73_ (PanelMenuBox* self, GdkEventKey* e) {
	gboolean result = FALSE;
	GdkEventKey _tmp0_ = {0};
	guint _tmp1_ = 0U;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = *e;
	_tmp1_ = _tmp0_.keyval;
	_tmp2_ = gdk_keyval_name (_tmp1_);
	if (g_strcmp0 (_tmp2_, "Escape") == 0) {
		PanelMenuHTML* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = self->priv->view;
		_tmp4_ = panel_menu_html_handleEsc (_tmp3_);
		if (_tmp4_ == FALSE) {
			panel_menu_box_dismiss (self);
		}
	} else {
		GdkEventKey _tmp5_ = {0};
		guint _tmp6_ = 0U;
		const gchar* _tmp7_ = NULL;
		_tmp5_ = *e;
		_tmp6_ = _tmp5_.keyval;
		_tmp7_ = gdk_keyval_name (_tmp6_);
		if (g_strcmp0 (_tmp7_, "Print") == 0) {
			gboolean _tmp8_ = FALSE;
			_tmp8_ = utils_print_screen ();
			if (_tmp8_ == FALSE) {
				FILE* _tmp9_ = NULL;
				_tmp9_ = stdout;
				fprintf (_tmp9_, "Unable to take screenshot\n");
			}
		}
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda73__gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = __lambda73_ ((PanelMenuBox*) self, event);
	return result;
}


PanelMenuBox* panel_menu_box_construct (GType object_type) {
	PanelMenuBox * self = NULL;
	PanelMenuHTML* _tmp4_ = NULL;
	PanelMenuHTML* _tmp5_ = NULL;
	PanelMenuHTML* _tmp6_ = NULL;
	GdkScreen* _tmp7_ = NULL;
	GdkScreen* _tmp8_ = NULL;
	GdkVisual* _tmp9_ = NULL;
	GdkRGBA c = {0};
	GdkRGBA _tmp10_ = {0};
	PanelMenuHTML* _tmp11_ = NULL;
	GError * _inner_error_ = NULL;
	self = (PanelMenuBox*) panel_abstract_window_construct (object_type);
	{
		GDBusConnection* bus = NULL;
		GDBusConnection* _tmp0_ = NULL;
		_tmp0_ = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &_inner_error_);
		bus = _tmp0_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch1_g_error;
		}
		g_dbus_connection_signal_subscribe (bus, NULL, "org.gtk.gio.DesktopAppInfo", "Launched", "/org/gtk/gio/DesktopAppInfo", NULL, 0, _panel_menu_box_dismiss_gd_bus_signal_callback, g_object_ref (self), g_object_unref);
		_g_object_unref0 (bus);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp1_ = NULL;
		GError* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp1_ = stderr;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		fprintf (_tmp1_, "Unable to subscribe to desktop launcher's \"Launched\" signal: %s\n", _tmp3_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = panel_menu_html_new ();
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->view);
	self->priv->view = _tmp4_;
	_tmp5_ = self->priv->view;
	gtk_widget_show_all ((GtkWidget*) _tmp5_);
	_tmp6_ = self->priv->view;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp6_);
	gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_DOCK);
	gtk_window_set_title ((GtkWindow*) self, "_manokwari_menu_");
	_tmp7_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp8_ = _tmp7_;
	_tmp9_ = gdk_screen_get_rgba_visual (_tmp8_);
	gtk_widget_set_visual ((GtkWidget*) self, _tmp9_);
	memset (&c, 0, sizeof (GdkRGBA));
	c.red = 0.0;
	c.blue = 0.0;
	c.green = 0.0;
	c.alpha = 0.0;
	_tmp10_ = c;
	gtk_widget_override_background_color ((GtkWidget*) self, GTK_STATE_FLAG_NORMAL, &_tmp10_);
	gtk_widget_set_app_paintable ((GtkWidget*) self, TRUE);
	panel_screen_move_window ((GtkWindow*) self, GDK_GRAVITY_NORTH_WEST);
	_tmp11_ = self->priv->view;
	panel_menu_html_start (_tmp11_);
	gtk_widget_hide ((GtkWidget*) self);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) ___lambda70__gtk_widget_button_press_event, self, 0);
	g_signal_connect_object ((PanelAbstractWindow*) self, "screen-size-changed", (GCallback) ___lambda71__panel_abstract_window_screen_size_changed, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "map-event", (GCallback) ___lambda72__gtk_widget_map_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) ___lambda73__gtk_widget_key_press_event, self, 0);
	return self;
}


PanelMenuBox* panel_menu_box_new (void) {
	return panel_menu_box_construct (TYPE_PANEL_MENU_BOX);
}


static void panel_menu_box_real_get_preferred_width (GtkWidget* base, gint* min, gint* max) {
	PanelMenuBox * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	self = (PanelMenuBox*) base;
	_vala_max = PANEL_MENU_BOX_COLUMN_WIDTH;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static void panel_menu_box_real_get_preferred_height (GtkWidget* base, gint* min, gint* max) {
	PanelMenuBox * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	GdkRectangle _tmp0_ = {0};
	gint _tmp1_ = 0;
	self = (PanelMenuBox*) base;
	panel_screen_get_primary_monitor_geometry (&_tmp0_);
	_tmp1_ = _tmp0_.height;
	_vala_max = _tmp1_;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static void panel_menu_box_dismiss (PanelMenuBox* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_visible ((GtkWidget*) self);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		FILE* _tmp2_ = NULL;
		_tmp2_ = stdout;
		fprintf (_tmp2_, "Menu box dismissed \n");
		utils_ungrab ((GtkWindow*) self);
		panel_menu_box_try_hide (self);
	}
}


static gboolean panel_menu_box_real_hide (PanelMenuBox* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_widget_hide ((GtkWidget*) self);
	result = FALSE;
	return result;
}


static gboolean _panel_menu_box_real_hide_gsource_func (gpointer self) {
	gboolean result;
	result = panel_menu_box_real_hide ((PanelMenuBox*) self);
	return result;
}


void panel_menu_box_try_hide (PanelMenuBox* self) {
	PanelMenuHTML* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->view;
	panel_menu_html_triggerHideAnimation (_tmp0_);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 500, _panel_menu_box_real_hide_gsource_func, g_object_ref (self), g_object_unref);
	g_signal_emit_by_name (self, "dismissed");
}


static void panel_menu_box_class_init (PanelMenuBoxClass * klass) {
	panel_menu_box_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelMenuBoxPrivate));
	((GtkWidgetClass *) klass)->get_preferred_width = panel_menu_box_real_get_preferred_width;
	((GtkWidgetClass *) klass)->get_preferred_height = panel_menu_box_real_get_preferred_height;
	G_OBJECT_CLASS (klass)->finalize = panel_menu_box_finalize;
	g_signal_new ("dismissed", TYPE_PANEL_MENU_BOX, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("shown", TYPE_PANEL_MENU_BOX, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("about_to_show_content", TYPE_PANEL_MENU_BOX, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void panel_menu_box_instance_init (PanelMenuBox * self) {
	self->priv = PANEL_MENU_BOX_GET_PRIVATE (self);
}


static void panel_menu_box_finalize (GObject* obj) {
	PanelMenuBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_MENU_BOX, PanelMenuBox);
	_g_object_unref0 (self->priv->view);
	G_OBJECT_CLASS (panel_menu_box_parent_class)->finalize (obj);
}


GType panel_menu_box_get_type (void) {
	static volatile gsize panel_menu_box_type_id__volatile = 0;
	if (g_once_init_enter (&panel_menu_box_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelMenuBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_menu_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelMenuBox), 0, (GInstanceInitFunc) panel_menu_box_instance_init, NULL };
		GType panel_menu_box_type_id;
		panel_menu_box_type_id = g_type_register_static (TYPE_PANEL_ABSTRACT_WINDOW, "PanelMenuBox", &g_define_type_info, 0);
		g_once_init_leave (&panel_menu_box_type_id__volatile, panel_menu_box_type_id);
	}
	return panel_menu_box_type_id__volatile;
}



