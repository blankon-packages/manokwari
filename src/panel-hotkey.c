/* panel-hotkey.c generated by valac 0.26.1, the Vala compiler
 * generated from panel-hotkey.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <gdk/gdk.h>
#include <gee.h>
#include <gdk/gdkx.h>
#include <gtk/gtk.h>
#include <gobject/gvaluecollector.h>


#define TYPE_PANEL_HOTKEY (panel_hotkey_get_type ())
#define PANEL_HOTKEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_HOTKEY, PanelHotkey))
#define PANEL_HOTKEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_HOTKEY, PanelHotkeyClass))
#define IS_PANEL_HOTKEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_HOTKEY))
#define IS_PANEL_HOTKEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_HOTKEY))
#define PANEL_HOTKEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_HOTKEY, PanelHotkeyClass))

typedef struct _PanelHotkey PanelHotkey;
typedef struct _PanelHotkeyClass PanelHotkeyClass;
#define _panel_hotkey_unref0(var) ((var == NULL) ? NULL : (var = (panel_hotkey_unref (var), NULL)))
typedef struct _PanelHotkeyPrivate PanelHotkeyPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define PANEL_HOTKEY_TYPE_KEY_BINDING (panel_hotkey_key_binding_get_type ())
#define PANEL_HOTKEY_KEY_BINDING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANEL_HOTKEY_TYPE_KEY_BINDING, PanelHotkeyKeyBinding))
#define PANEL_HOTKEY_KEY_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANEL_HOTKEY_TYPE_KEY_BINDING, PanelHotkeyKeyBindingClass))
#define PANEL_HOTKEY_IS_KEY_BINDING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANEL_HOTKEY_TYPE_KEY_BINDING))
#define PANEL_HOTKEY_IS_KEY_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANEL_HOTKEY_TYPE_KEY_BINDING))
#define PANEL_HOTKEY_KEY_BINDING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANEL_HOTKEY_TYPE_KEY_BINDING, PanelHotkeyKeyBindingClass))

typedef struct _PanelHotkeyKeyBinding PanelHotkeyKeyBinding;
typedef struct _PanelHotkeyKeyBindingClass PanelHotkeyKeyBindingClass;
typedef struct _PanelHotkeyKeyBindingPrivate PanelHotkeyKeyBindingPrivate;
#define _panel_hotkey_key_binding_unref0(var) ((var == NULL) ? NULL : (var = (panel_hotkey_key_binding_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _PanelHotkeyParamSpecKeyBinding PanelHotkeyParamSpecKeyBinding;
typedef struct _ParamSpecPanelHotkey ParamSpecPanelHotkey;

struct _PanelHotkey {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PanelHotkeyPrivate * priv;
};

struct _PanelHotkeyClass {
	GTypeClass parent_class;
	void (*finalize) (PanelHotkey *self);
};

struct _PanelHotkeyPrivate {
	Display* display;
	GdkWindow* root_window;
	XID x_id;
};

struct _PanelHotkeyKeyBinding {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PanelHotkeyKeyBindingPrivate * priv;
	gchar* combination;
	guint key_code;
	guint modifiers;
};

struct _PanelHotkeyKeyBindingClass {
	GTypeClass parent_class;
	void (*finalize) (PanelHotkeyKeyBinding *self);
};

struct _PanelHotkeyParamSpecKeyBinding {
	GParamSpec parent_instance;
};

struct _ParamSpecPanelHotkey {
	GParamSpec parent_instance;
};


static gpointer panel_hotkey_parent_class = NULL;
static PanelHotkey* panel_hotkey__instance;
static PanelHotkey* panel_hotkey__instance = NULL;
static guint* panel_hotkey_lock_modifiers;
static gint panel_hotkey_lock_modifiers_length1;
static guint* panel_hotkey_lock_modifiers = NULL;
static gint panel_hotkey_lock_modifiers_length1 = 0;
static gint _panel_hotkey_lock_modifiers_size_ = 0;
static GeeList* panel_hotkey_bindings;
static GeeList* panel_hotkey_bindings = NULL;
static gpointer panel_hotkey_key_binding_parent_class = NULL;

void static_handler (const gchar* a);
gpointer panel_hotkey_ref (gpointer instance);
void panel_hotkey_unref (gpointer instance);
GParamSpec* param_spec_panel_hotkey (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_panel_hotkey (GValue* value, gpointer v_object);
void value_take_panel_hotkey (GValue* value, gpointer v_object);
gpointer value_get_panel_hotkey (const GValue* value);
GType panel_hotkey_get_type (void) G_GNUC_CONST;
PanelHotkey* panel_hotkey_instance (void);
#define PANEL_HOTKEY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_HOTKEY, PanelHotkeyPrivate))
enum  {
	PANEL_HOTKEY_DUMMY_PROPERTY
};
static gpointer panel_hotkey_key_binding_ref (gpointer instance);
static void panel_hotkey_key_binding_unref (gpointer instance);
static GParamSpec* panel_hotkey_param_spec_key_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void panel_hotkey_value_set_key_binding (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void panel_hotkey_value_take_key_binding (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer panel_hotkey_value_get_key_binding (const GValue* value) G_GNUC_UNUSED;
static GType panel_hotkey_key_binding_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
PanelHotkey* panel_hotkey_new (void);
PanelHotkey* panel_hotkey_construct (GType object_type);
GdkFilterReturn panel_hotkey_event_filter (PanelHotkey* self, GdkXEvent* gxevent, GdkEvent* event);
static GdkFilterReturn _panel_hotkey_event_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self);
void panel_hotkey_bind (PanelHotkey* self, const gchar* combination);
static PanelHotkeyKeyBinding* panel_hotkey_key_binding_new (const gchar* combination, guint key_code, guint modifiers);
static PanelHotkeyKeyBinding* panel_hotkey_key_binding_construct (GType object_type, const gchar* combination, guint key_code, guint modifiers);
enum  {
	PANEL_HOTKEY_KEY_BINDING_DUMMY_PROPERTY
};
static void panel_hotkey_key_binding_finalize (PanelHotkeyKeyBinding* obj);
static void panel_hotkey_finalize (PanelHotkey* obj);


void static_handler (const gchar* a) {
	PanelHotkey* _tmp0_ = NULL;
	PanelHotkey* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (a != NULL);
	_tmp0_ = panel_hotkey_instance ();
	_tmp1_ = _tmp0_;
	_tmp2_ = a;
	g_signal_emit_by_name (_tmp1_, "triggered", _tmp2_);
	_panel_hotkey_unref0 (_tmp1_);
}


static gpointer _panel_hotkey_ref0 (gpointer self) {
	return self ? panel_hotkey_ref (self) : NULL;
}


PanelHotkey* panel_hotkey_instance (void) {
	PanelHotkey* result = NULL;
	PanelHotkey* _tmp0_ = NULL;
	PanelHotkey* _tmp1_ = NULL;
	_tmp0_ = panel_hotkey__instance;
	_tmp1_ = _panel_hotkey_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GdkFilterReturn _panel_hotkey_event_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self) {
	GdkFilterReturn result;
	result = panel_hotkey_event_filter ((PanelHotkey*) self, xevent, event);
	return result;
}


PanelHotkey* panel_hotkey_construct (GType object_type) {
	PanelHotkey* self = NULL;
	PanelHotkey* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	GdkWindow* _tmp3_ = NULL;
	Display* _tmp4_ = NULL;
	GdkWindow* _tmp5_ = NULL;
	Window _tmp6_ = 0;
	GdkWindow* _tmp7_ = NULL;
	self = (PanelHotkey*) g_type_create_instance (object_type);
	_tmp0_ = _panel_hotkey_ref0 (self);
	_panel_hotkey_unref0 (panel_hotkey__instance);
	panel_hotkey__instance = _tmp0_;
	_tmp1_ = gee_array_list_new (PANEL_HOTKEY_TYPE_KEY_BINDING, (GBoxedCopyFunc) panel_hotkey_key_binding_ref, panel_hotkey_key_binding_unref, NULL);
	_g_object_unref0 (panel_hotkey_bindings);
	panel_hotkey_bindings = (GeeList*) _tmp1_;
	_tmp2_ = gdk_get_default_root_window ();
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->root_window);
	self->priv->root_window = _tmp3_;
	_tmp4_ = gdk_x11_get_default_xdisplay ();
	self->priv->display = _tmp4_;
	_tmp5_ = self->priv->root_window;
	_tmp6_ = gdk_x11_window_get_xid (_tmp5_);
	self->priv->x_id = (XID) _tmp6_;
	_tmp7_ = self->priv->root_window;
	gdk_window_add_filter (_tmp7_, _panel_hotkey_event_filter_gdk_filter_func, self);
	return self;
}


PanelHotkey* panel_hotkey_new (void) {
	return panel_hotkey_construct (TYPE_PANEL_HOTKEY);
}


GdkFilterReturn panel_hotkey_event_filter (PanelHotkey* self, GdkXEvent* gxevent, GdkEvent* event) {
	GdkFilterReturn result = 0;
	GdkFilterReturn filter = 0;
	void* p = NULL;
	XEvent* xevent = NULL;
	void* _tmp0_ = NULL;
	XEvent* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (gxevent != NULL, 0);
	g_return_val_if_fail (event != NULL, 0);
	filter = GDK_FILTER_CONTINUE;
	p = gxevent;
	_tmp0_ = p;
	xevent = (XEvent*) _tmp0_;
	_tmp1_ = xevent;
	_tmp2_ = (*_tmp1_).type;
	if (_tmp2_ == ((gint) KeyPress)) {
		{
			GeeList* _binding_list = NULL;
			GeeList* _tmp3_ = NULL;
			GeeList* _tmp4_ = NULL;
			gint _binding_size = 0;
			GeeList* _tmp5_ = NULL;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			gint _binding_index = 0;
			_tmp3_ = panel_hotkey_bindings;
			_tmp4_ = _g_object_ref0 (_tmp3_);
			_binding_list = _tmp4_;
			_tmp5_ = _binding_list;
			_tmp6_ = gee_collection_get_size ((GeeCollection*) _tmp5_);
			_tmp7_ = _tmp6_;
			_binding_size = _tmp7_;
			_binding_index = -1;
			while (TRUE) {
				gint _tmp8_ = 0;
				gint _tmp9_ = 0;
				gint _tmp10_ = 0;
				PanelHotkeyKeyBinding* binding = NULL;
				GeeList* _tmp11_ = NULL;
				gint _tmp12_ = 0;
				gpointer _tmp13_ = NULL;
				gboolean _tmp14_ = FALSE;
				XEvent* _tmp15_ = NULL;
				XKeyEvent _tmp16_ = {0};
				guint _tmp17_ = 0U;
				PanelHotkeyKeyBinding* _tmp18_ = NULL;
				guint _tmp19_ = 0U;
				_tmp8_ = _binding_index;
				_binding_index = _tmp8_ + 1;
				_tmp9_ = _binding_index;
				_tmp10_ = _binding_size;
				if (!(_tmp9_ < _tmp10_)) {
					break;
				}
				_tmp11_ = _binding_list;
				_tmp12_ = _binding_index;
				_tmp13_ = gee_list_get (_tmp11_, _tmp12_);
				binding = (PanelHotkeyKeyBinding*) _tmp13_;
				_tmp15_ = xevent;
				_tmp16_ = (*_tmp15_).xkey;
				_tmp17_ = _tmp16_.keycode;
				_tmp18_ = binding;
				_tmp19_ = _tmp18_->key_code;
				if (_tmp17_ == _tmp19_) {
					XEvent* _tmp20_ = NULL;
					XKeyEvent _tmp21_ = {0};
					guint _tmp22_ = 0U;
					guint* _tmp23_ = NULL;
					gint _tmp23__length1 = 0;
					guint _tmp24_ = 0U;
					PanelHotkeyKeyBinding* _tmp25_ = NULL;
					guint _tmp26_ = 0U;
					_tmp20_ = xevent;
					_tmp21_ = (*_tmp20_).xkey;
					_tmp22_ = _tmp21_.state;
					_tmp23_ = panel_hotkey_lock_modifiers;
					_tmp23__length1 = panel_hotkey_lock_modifiers_length1;
					_tmp24_ = _tmp23_[7];
					_tmp25_ = binding;
					_tmp26_ = _tmp25_->modifiers;
					_tmp14_ = (_tmp22_ & (~_tmp24_)) == _tmp26_;
				} else {
					_tmp14_ = FALSE;
				}
				if (_tmp14_) {
					PanelHotkeyKeyBinding* _tmp27_ = NULL;
					const gchar* _tmp28_ = NULL;
					_tmp27_ = binding;
					_tmp28_ = _tmp27_->combination;
					static_handler (_tmp28_);
				}
				_panel_hotkey_key_binding_unref0 (binding);
			}
			_g_object_unref0 (_binding_list);
		}
	}
	result = filter;
	return result;
}


void panel_hotkey_bind (PanelHotkey* self, const gchar* combination) {
	guint key_sym = 0U;
	GdkModifierType modifiers = 0;
	const gchar* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	GdkModifierType _tmp2_ = 0;
	guchar key_code = '\0';
	Display* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	guchar _tmp5_ = '\0';
	guchar _tmp6_ = '\0';
	g_return_if_fail (self != NULL);
	g_return_if_fail (combination != NULL);
	_tmp0_ = combination;
	gtk_accelerator_parse (_tmp0_, &_tmp1_, &_tmp2_);
	key_sym = _tmp1_;
	modifiers = _tmp2_;
	_tmp3_ = self->priv->display;
	_tmp4_ = key_sym;
	_tmp5_ = XKeysymToKeycode (_tmp3_, (gulong) _tmp4_);
	key_code = _tmp5_;
	_tmp6_ = key_code;
	if (((gint) _tmp6_) != 0) {
		guint* _tmp7_ = NULL;
		gint _tmp7__length1 = 0;
		PanelHotkeyKeyBinding* binding = NULL;
		const gchar* _tmp13_ = NULL;
		guchar _tmp14_ = '\0';
		GdkModifierType _tmp15_ = 0;
		PanelHotkeyKeyBinding* _tmp16_ = NULL;
		GeeList* _tmp17_ = NULL;
		PanelHotkeyKeyBinding* _tmp18_ = NULL;
		gdk_error_trap_push ();
		_tmp7_ = panel_hotkey_lock_modifiers;
		_tmp7__length1 = panel_hotkey_lock_modifiers_length1;
		{
			guint* mod_collection = NULL;
			gint mod_collection_length1 = 0;
			gint _mod_collection_size_ = 0;
			gint mod_it = 0;
			mod_collection = _tmp7_;
			mod_collection_length1 = _tmp7__length1;
			for (mod_it = 0; mod_it < _tmp7__length1; mod_it = mod_it + 1) {
				guint mod = 0U;
				mod = mod_collection[mod_it];
				{
					Display* _tmp8_ = NULL;
					guchar _tmp9_ = '\0';
					GdkModifierType _tmp10_ = 0;
					guint _tmp11_ = 0U;
					XID _tmp12_ = 0;
					_tmp8_ = self->priv->display;
					_tmp9_ = key_code;
					_tmp10_ = modifiers;
					_tmp11_ = mod;
					_tmp12_ = self->priv->x_id;
					XGrabKey (_tmp8_, (gint) _tmp9_, (guint) (_tmp10_ | _tmp11_), (Window) _tmp12_, FALSE, (gint) GrabModeAsync, (gint) GrabModeAsync);
				}
			}
		}
		gdk_flush ();
		_tmp13_ = combination;
		_tmp14_ = key_code;
		_tmp15_ = modifiers;
		_tmp16_ = panel_hotkey_key_binding_new (_tmp13_, (guint) _tmp14_, (guint) _tmp15_);
		binding = _tmp16_;
		_tmp17_ = panel_hotkey_bindings;
		_tmp18_ = binding;
		gee_collection_add ((GeeCollection*) _tmp17_, _tmp18_);
		_panel_hotkey_key_binding_unref0 (binding);
	}
}


static PanelHotkeyKeyBinding* panel_hotkey_key_binding_construct (GType object_type, const gchar* combination, guint key_code, guint modifiers) {
	PanelHotkeyKeyBinding* self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	guint _tmp3_ = 0U;
	g_return_val_if_fail (combination != NULL, NULL);
	self = (PanelHotkeyKeyBinding*) g_type_create_instance (object_type);
	_tmp0_ = combination;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->combination);
	self->combination = _tmp1_;
	_tmp2_ = key_code;
	self->key_code = _tmp2_;
	_tmp3_ = modifiers;
	self->modifiers = _tmp3_;
	return self;
}


static PanelHotkeyKeyBinding* panel_hotkey_key_binding_new (const gchar* combination, guint key_code, guint modifiers) {
	return panel_hotkey_key_binding_construct (PANEL_HOTKEY_TYPE_KEY_BINDING, combination, key_code, modifiers);
}


static void panel_hotkey_value_key_binding_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void panel_hotkey_value_key_binding_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		panel_hotkey_key_binding_unref (value->data[0].v_pointer);
	}
}


static void panel_hotkey_value_key_binding_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = panel_hotkey_key_binding_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer panel_hotkey_value_key_binding_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* panel_hotkey_value_key_binding_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		PanelHotkeyKeyBinding* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = panel_hotkey_key_binding_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* panel_hotkey_value_key_binding_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	PanelHotkeyKeyBinding** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = panel_hotkey_key_binding_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* panel_hotkey_param_spec_key_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	PanelHotkeyParamSpecKeyBinding* spec;
	g_return_val_if_fail (g_type_is_a (object_type, PANEL_HOTKEY_TYPE_KEY_BINDING), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer panel_hotkey_value_get_key_binding (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PANEL_HOTKEY_TYPE_KEY_BINDING), NULL);
	return value->data[0].v_pointer;
}


static void panel_hotkey_value_set_key_binding (GValue* value, gpointer v_object) {
	PanelHotkeyKeyBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PANEL_HOTKEY_TYPE_KEY_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PANEL_HOTKEY_TYPE_KEY_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		panel_hotkey_key_binding_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panel_hotkey_key_binding_unref (old);
	}
}


static void panel_hotkey_value_take_key_binding (GValue* value, gpointer v_object) {
	PanelHotkeyKeyBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PANEL_HOTKEY_TYPE_KEY_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PANEL_HOTKEY_TYPE_KEY_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panel_hotkey_key_binding_unref (old);
	}
}


static void panel_hotkey_key_binding_class_init (PanelHotkeyKeyBindingClass * klass) {
	panel_hotkey_key_binding_parent_class = g_type_class_peek_parent (klass);
	((PanelHotkeyKeyBindingClass *) klass)->finalize = panel_hotkey_key_binding_finalize;
}


static void panel_hotkey_key_binding_instance_init (PanelHotkeyKeyBinding * self) {
	self->ref_count = 1;
}


static void panel_hotkey_key_binding_finalize (PanelHotkeyKeyBinding* obj) {
	PanelHotkeyKeyBinding * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PANEL_HOTKEY_TYPE_KEY_BINDING, PanelHotkeyKeyBinding);
	g_signal_handlers_destroy (self);
	_g_free0 (self->combination);
}


static GType panel_hotkey_key_binding_get_type (void) {
	static volatile gsize panel_hotkey_key_binding_type_id__volatile = 0;
	if (g_once_init_enter (&panel_hotkey_key_binding_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { panel_hotkey_value_key_binding_init, panel_hotkey_value_key_binding_free_value, panel_hotkey_value_key_binding_copy_value, panel_hotkey_value_key_binding_peek_pointer, "p", panel_hotkey_value_key_binding_collect_value, "p", panel_hotkey_value_key_binding_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PanelHotkeyKeyBindingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_hotkey_key_binding_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelHotkeyKeyBinding), 0, (GInstanceInitFunc) panel_hotkey_key_binding_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType panel_hotkey_key_binding_type_id;
		panel_hotkey_key_binding_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PanelHotkeyKeyBinding", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&panel_hotkey_key_binding_type_id__volatile, panel_hotkey_key_binding_type_id);
	}
	return panel_hotkey_key_binding_type_id__volatile;
}


static gpointer panel_hotkey_key_binding_ref (gpointer instance) {
	PanelHotkeyKeyBinding* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void panel_hotkey_key_binding_unref (gpointer instance) {
	PanelHotkeyKeyBinding* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PANEL_HOTKEY_KEY_BINDING_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void value_panel_hotkey_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_panel_hotkey_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		panel_hotkey_unref (value->data[0].v_pointer);
	}
}


static void value_panel_hotkey_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = panel_hotkey_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_panel_hotkey_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_panel_hotkey_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		PanelHotkey* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = panel_hotkey_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_panel_hotkey_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	PanelHotkey** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = panel_hotkey_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_panel_hotkey (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecPanelHotkey* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PANEL_HOTKEY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_panel_hotkey (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PANEL_HOTKEY), NULL);
	return value->data[0].v_pointer;
}


void value_set_panel_hotkey (GValue* value, gpointer v_object) {
	PanelHotkey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PANEL_HOTKEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PANEL_HOTKEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		panel_hotkey_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panel_hotkey_unref (old);
	}
}


void value_take_panel_hotkey (GValue* value, gpointer v_object) {
	PanelHotkey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PANEL_HOTKEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PANEL_HOTKEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panel_hotkey_unref (old);
	}
}


static void panel_hotkey_class_init (PanelHotkeyClass * klass) {
	guint* _tmp0_ = NULL;
	panel_hotkey_parent_class = g_type_class_peek_parent (klass);
	((PanelHotkeyClass *) klass)->finalize = panel_hotkey_finalize;
	g_type_class_add_private (klass, sizeof (PanelHotkeyPrivate));
	g_signal_new ("triggered", TYPE_PANEL_HOTKEY, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	_tmp0_ = g_new0 (guint, 8);
	_tmp0_[0] = (guint) 0;
	_tmp0_[1] = (guint) GDK_MOD2_MASK;
	_tmp0_[2] = (guint) GDK_LOCK_MASK;
	_tmp0_[3] = (guint) GDK_MOD5_MASK;
	_tmp0_[4] = (guint) (GDK_MOD2_MASK | GDK_LOCK_MASK);
	_tmp0_[5] = (guint) (GDK_MOD2_MASK | GDK_MOD5_MASK);
	_tmp0_[6] = (guint) (GDK_LOCK_MASK | GDK_MOD5_MASK);
	_tmp0_[7] = (guint) ((GDK_MOD2_MASK | GDK_LOCK_MASK) | GDK_MOD5_MASK);
	panel_hotkey_lock_modifiers = _tmp0_;
	panel_hotkey_lock_modifiers_length1 = 8;
}


static void panel_hotkey_instance_init (PanelHotkey * self) {
	self->priv = PANEL_HOTKEY_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void panel_hotkey_finalize (PanelHotkey* obj) {
	PanelHotkey * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_HOTKEY, PanelHotkey);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->root_window);
}


GType panel_hotkey_get_type (void) {
	static volatile gsize panel_hotkey_type_id__volatile = 0;
	if (g_once_init_enter (&panel_hotkey_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_panel_hotkey_init, value_panel_hotkey_free_value, value_panel_hotkey_copy_value, value_panel_hotkey_peek_pointer, "p", value_panel_hotkey_collect_value, "p", value_panel_hotkey_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PanelHotkeyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_hotkey_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelHotkey), 0, (GInstanceInitFunc) panel_hotkey_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType panel_hotkey_type_id;
		panel_hotkey_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PanelHotkey", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&panel_hotkey_type_id__volatile, panel_hotkey_type_id);
	}
	return panel_hotkey_type_id__volatile;
}


gpointer panel_hotkey_ref (gpointer instance) {
	PanelHotkey* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void panel_hotkey_unref (gpointer instance) {
	PanelHotkey* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PANEL_HOTKEY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



