/* panel-session-manager.c generated by valac 0.26.1, the Vala compiler
 * generated from panel-session-manager.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <JavaScriptCore/JavaScript.h>
#include <stdio.h>
#include <gtk/gtk.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SESSION_MANAGER (session_manager_get_type ())
#define SESSION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SESSION_MANAGER, SessionManager))
#define IS_SESSION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SESSION_MANAGER))
#define SESSION_MANAGER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_SESSION_MANAGER, SessionManagerIface))

typedef struct _SessionManager SessionManager;
typedef struct _SessionManagerIface SessionManagerIface;

#define TYPE_SESSION_MANAGER_PROXY (session_manager_proxy_get_type ())
typedef GDBusProxy SessionManagerProxy;
typedef GDBusProxyClass SessionManagerProxyClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_CLIENT_PRIVATE (client_private_get_type ())
#define CLIENT_PRIVATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLIENT_PRIVATE, ClientPrivate))
#define IS_CLIENT_PRIVATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLIENT_PRIVATE))
#define CLIENT_PRIVATE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_CLIENT_PRIVATE, ClientPrivateIface))

typedef struct _ClientPrivate ClientPrivate;
typedef struct _ClientPrivateIface ClientPrivateIface;

#define TYPE_CLIENT_PRIVATE_PROXY (client_private_proxy_get_type ())
typedef GDBusProxy ClientPrivateProxy;
typedef GDBusProxyClass ClientPrivateProxyClass;

#define TYPE_PANEL_SESSION_MANAGER (panel_session_manager_get_type ())
#define PANEL_SESSION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_SESSION_MANAGER, PanelSessionManager))
#define PANEL_SESSION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_SESSION_MANAGER, PanelSessionManagerClass))
#define IS_PANEL_SESSION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_SESSION_MANAGER))
#define IS_PANEL_SESSION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_SESSION_MANAGER))
#define PANEL_SESSION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_SESSION_MANAGER, PanelSessionManagerClass))

typedef struct _PanelSessionManager PanelSessionManager;
typedef struct _PanelSessionManagerClass PanelSessionManagerClass;
typedef struct _PanelSessionManagerPrivate PanelSessionManagerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _panel_session_manager_unref0(var) ((var == NULL) ? NULL : (var = (panel_session_manager_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _PanelSessionManagerLogoutData PanelSessionManagerLogoutData;
typedef struct _PanelSessionManagerShutdownData PanelSessionManagerShutdownData;
#define _0(var) ((var == NULL) ? NULL : (var = ( (var), NULL)))
#define _JSStringRelease0(var) ((var == NULL) ? NULL : (var = (JSStringRelease (var), NULL)))
#define _JSClassRelease0(var) ((var == NULL) ? NULL : (var = (JSClassRelease (var), NULL)))
typedef struct _ParamSpecPanelSessionManager ParamSpecPanelSessionManager;

struct _SessionManagerIface {
	GTypeInterface parent_iface;
	void (*register_client) (SessionManager* self, const gchar* app_id, const gchar* startup_id, char** path, GError** error);
	void (*shutdown) (SessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*shutdown_finish) (SessionManager* self, GAsyncResult* _res_, GError** error);
	void (*logout) (SessionManager* self, guint32 mode, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*logout_finish) (SessionManager* self, GAsyncResult* _res_, GError** error);
	gboolean (*can_shutdown) (SessionManager* self, GError** error);
};

struct _ClientPrivateIface {
	GTypeInterface parent_iface;
	void (*end_session_response) (ClientPrivate* self, gboolean ok, const gchar* reason, GError** error);
};

struct _PanelSessionManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PanelSessionManagerPrivate * priv;
};

struct _PanelSessionManagerClass {
	GTypeClass parent_class;
	void (*finalize) (PanelSessionManager *self);
};

struct _PanelSessionManagerPrivate {
	SessionManager* session;
	ClientPrivate* client;
};

struct _PanelSessionManagerLogoutData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PanelSessionManager* self;
	SessionManager* _tmp0_;
	SessionManager* _tmp1_;
	GError* e;
	FILE* _tmp2_;
	GError* _tmp3_;
	const gchar* _tmp4_;
	GError * _inner_error_;
};

struct _PanelSessionManagerShutdownData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PanelSessionManager* self;
	SessionManager* _tmp0_;
	SessionManager* _tmp1_;
	GError* e;
	FILE* _tmp2_;
	GError* _tmp3_;
	const gchar* _tmp4_;
	GError * _inner_error_;
};

struct _ParamSpecPanelSessionManager {
	GParamSpec parent_instance;
};


static gpointer panel_session_manager_parent_class = NULL;
static char* panel_session_manager_session_id;
static char* panel_session_manager_session_id = NULL;
static PanelSessionManager* panel_session_manager_instance;
static PanelSessionManager* panel_session_manager_instance = NULL;

GType session_manager_proxy_get_type (void) G_GNUC_CONST;
guint session_manager_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType session_manager_get_type (void) G_GNUC_CONST;
void session_manager_register_client (SessionManager* self, const gchar* app_id, const gchar* startup_id, char** path, GError** error);
void session_manager_shutdown (SessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void session_manager_shutdown_finish (SessionManager* self, GAsyncResult* _res_, GError** error);
void session_manager_logout (SessionManager* self, guint32 mode, GAsyncReadyCallback _callback_, gpointer _user_data_);
void session_manager_logout_finish (SessionManager* self, GAsyncResult* _res_, GError** error);
gboolean session_manager_can_shutdown (SessionManager* self, GError** error);
static void session_manager_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void session_manager_proxy_register_client (SessionManager* self, const gchar* app_id, const gchar* startup_id, char** path, GError** error);
static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data);
static void session_manager_proxy_shutdown_async (SessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void session_manager_proxy_shutdown_finish (SessionManager* self, GAsyncResult* _res_, GError** error);
static void session_manager_proxy_logout_async (SessionManager* self, guint32 mode, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void session_manager_proxy_logout_finish (SessionManager* self, GAsyncResult* _res_, GError** error);
static gboolean session_manager_proxy_can_shutdown (SessionManager* self, GError** error);
static void session_manager_proxy_session_manager_interface_init (SessionManagerIface* iface);
static void _dbus_session_manager_register_client (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_session_manager_shutdown (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_session_manager_shutdown_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_session_manager_logout (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_session_manager_logout_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_session_manager_can_shutdown (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void session_manager_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* session_manager_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean session_manager_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _session_manager_unregister_object (gpointer user_data);
GType client_private_proxy_get_type (void) G_GNUC_CONST;
guint client_private_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType client_private_get_type (void) G_GNUC_CONST;
void client_private_end_session_response (ClientPrivate* self, gboolean ok, const gchar* reason, GError** error);
static void client_private_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void _dbus_handle_client_private_query_end_session (ClientPrivate* self, GVariant* parameters);
static void _dbus_handle_client_private_end_session (ClientPrivate* self, GVariant* parameters);
static void client_private_proxy_end_session_response (ClientPrivate* self, gboolean ok, const gchar* reason, GError** error);
static void client_private_proxy_client_private_interface_init (ClientPrivateIface* iface);
static void _dbus_client_private_end_session_response (ClientPrivate* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void client_private_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* client_private_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean client_private_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_client_private_query_end_session (GObject* _sender, guint flags, gpointer* _data);
static void _dbus_client_private_end_session (GObject* _sender, guint flags, gpointer* _data);
static void _client_private_unregister_object (gpointer user_data);
gpointer panel_session_manager_ref (gpointer instance);
void panel_session_manager_unref (gpointer instance);
GParamSpec* param_spec_panel_session_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_panel_session_manager (GValue* value, gpointer v_object);
void value_take_panel_session_manager (GValue* value, gpointer v_object);
gpointer value_get_panel_session_manager (const GValue* value);
GType panel_session_manager_get_type (void) G_GNUC_CONST;
#define PANEL_SESSION_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_SESSION_MANAGER, PanelSessionManagerPrivate))
enum  {
	PANEL_SESSION_MANAGER_DUMMY_PROPERTY
};
void* panel_session_manager_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception);
static void* _panel_session_manager_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception);
PanelSessionManager* panel_session_manager_getInstance (void);
static PanelSessionManager* panel_session_manager_new (void);
static PanelSessionManager* panel_session_manager_construct (GType object_type);
void panel_session_manager_register (PanelSessionManager* self);
static void _____lambda9_ (PanelSessionManager* self, guint flags);
static void panel_session_manager_send_end_response (PanelSessionManager* self);
static void ______lambda9__client_private_end_session (ClientPrivate* _sender, guint flags, gpointer self);
static void _____lambda10_ (PanelSessionManager* self, guint flags);
static void ______lambda10__client_private_query_end_session (ClientPrivate* _sender, guint flags, gpointer self);
static void panel_session_manager_logout_data_free (gpointer _data);
void panel_session_manager_logout (PanelSessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void panel_session_manager_logout_finish (PanelSessionManager* self, GAsyncResult* _res_);
static gboolean panel_session_manager_logout_co (PanelSessionManagerLogoutData* _data_);
static void panel_session_manager_shutdown_data_free (gpointer _data);
void panel_session_manager_shutdown (PanelSessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void panel_session_manager_shutdown_finish (PanelSessionManager* self, GAsyncResult* _res_);
static gboolean panel_session_manager_shutdown_co (PanelSessionManagerShutdownData* _data_);
gboolean panel_session_manager_can_shutdown (PanelSessionManager* self);
void* panel_session_manager_js_can_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _panel_session_manager_js_can_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* panel_session_manager_js_logout (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _panel_session_manager_js_logout_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* panel_session_manager_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _panel_session_manager_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void panel_session_manager_setup_js_class (void* context);
static void panel_session_manager_finalize (PanelSessionManager* obj);

static const GDBusArgInfo _session_manager_dbus_arg_info_register_client_app_id = {-1, "app_id", "s"};
static const GDBusArgInfo _session_manager_dbus_arg_info_register_client_startup_id = {-1, "startup_id", "s"};
static const GDBusArgInfo _session_manager_dbus_arg_info_register_client_path = {-1, "path", "o"};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_register_client_in[] = {&_session_manager_dbus_arg_info_register_client_app_id, &_session_manager_dbus_arg_info_register_client_startup_id, NULL};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_register_client_out[] = {&_session_manager_dbus_arg_info_register_client_path, NULL};
static const GDBusMethodInfo _session_manager_dbus_method_info_register_client = {-1, "RegisterClient", (GDBusArgInfo **) (&_session_manager_dbus_arg_info_register_client_in), (GDBusArgInfo **) (&_session_manager_dbus_arg_info_register_client_out)};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_shutdown_in[] = {NULL};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_shutdown_out[] = {NULL};
static const GDBusMethodInfo _session_manager_dbus_method_info_shutdown = {-1, "Shutdown", (GDBusArgInfo **) (&_session_manager_dbus_arg_info_shutdown_in), (GDBusArgInfo **) (&_session_manager_dbus_arg_info_shutdown_out)};
static const GDBusArgInfo _session_manager_dbus_arg_info_logout_mode = {-1, "mode", "u"};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_logout_in[] = {&_session_manager_dbus_arg_info_logout_mode, NULL};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_logout_out[] = {NULL};
static const GDBusMethodInfo _session_manager_dbus_method_info_logout = {-1, "Logout", (GDBusArgInfo **) (&_session_manager_dbus_arg_info_logout_in), (GDBusArgInfo **) (&_session_manager_dbus_arg_info_logout_out)};
static const GDBusArgInfo _session_manager_dbus_arg_info_can_shutdown_result = {-1, "result", "b"};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_can_shutdown_in[] = {NULL};
static const GDBusArgInfo * const _session_manager_dbus_arg_info_can_shutdown_out[] = {&_session_manager_dbus_arg_info_can_shutdown_result, NULL};
static const GDBusMethodInfo _session_manager_dbus_method_info_can_shutdown = {-1, "CanShutdown", (GDBusArgInfo **) (&_session_manager_dbus_arg_info_can_shutdown_in), (GDBusArgInfo **) (&_session_manager_dbus_arg_info_can_shutdown_out)};
static const GDBusMethodInfo * const _session_manager_dbus_method_info[] = {&_session_manager_dbus_method_info_register_client, &_session_manager_dbus_method_info_shutdown, &_session_manager_dbus_method_info_logout, &_session_manager_dbus_method_info_can_shutdown, NULL};
static const GDBusSignalInfo * const _session_manager_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _session_manager_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _session_manager_dbus_interface_info = {-1, "org.gnome.SessionManager", (GDBusMethodInfo **) (&_session_manager_dbus_method_info), (GDBusSignalInfo **) (&_session_manager_dbus_signal_info), (GDBusPropertyInfo **) (&_session_manager_dbus_property_info)};
static const GDBusInterfaceVTable _session_manager_dbus_interface_vtable = {session_manager_dbus_interface_method_call, session_manager_dbus_interface_get_property, session_manager_dbus_interface_set_property};
static const GDBusArgInfo _client_private_dbus_arg_info_end_session_response_ok = {-1, "ok", "b"};
static const GDBusArgInfo _client_private_dbus_arg_info_end_session_response_reason = {-1, "reason", "s"};
static const GDBusArgInfo * const _client_private_dbus_arg_info_end_session_response_in[] = {&_client_private_dbus_arg_info_end_session_response_ok, &_client_private_dbus_arg_info_end_session_response_reason, NULL};
static const GDBusArgInfo * const _client_private_dbus_arg_info_end_session_response_out[] = {NULL};
static const GDBusMethodInfo _client_private_dbus_method_info_end_session_response = {-1, "EndSessionResponse", (GDBusArgInfo **) (&_client_private_dbus_arg_info_end_session_response_in), (GDBusArgInfo **) (&_client_private_dbus_arg_info_end_session_response_out)};
static const GDBusMethodInfo * const _client_private_dbus_method_info[] = {&_client_private_dbus_method_info_end_session_response, NULL};
static const GDBusArgInfo _client_private_dbus_arg_info_query_end_session_flags = {-1, "flags", "u"};
static const GDBusArgInfo * const _client_private_dbus_arg_info_query_end_session[] = {&_client_private_dbus_arg_info_query_end_session_flags, NULL};
static const GDBusSignalInfo _client_private_dbus_signal_info_query_end_session = {-1, "QueryEndSession", (GDBusArgInfo **) (&_client_private_dbus_arg_info_query_end_session)};
static const GDBusArgInfo _client_private_dbus_arg_info_end_session_flags = {-1, "flags", "u"};
static const GDBusArgInfo * const _client_private_dbus_arg_info_end_session[] = {&_client_private_dbus_arg_info_end_session_flags, NULL};
static const GDBusSignalInfo _client_private_dbus_signal_info_end_session = {-1, "EndSession", (GDBusArgInfo **) (&_client_private_dbus_arg_info_end_session)};
static const GDBusSignalInfo * const _client_private_dbus_signal_info[] = {&_client_private_dbus_signal_info_query_end_session, &_client_private_dbus_signal_info_end_session, NULL};
static const GDBusPropertyInfo * const _client_private_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _client_private_dbus_interface_info = {-1, "org.gnome.SessionManager.ClientPrivate", (GDBusMethodInfo **) (&_client_private_dbus_method_info), (GDBusSignalInfo **) (&_client_private_dbus_signal_info), (GDBusPropertyInfo **) (&_client_private_dbus_property_info)};
static const GDBusInterfaceVTable _client_private_dbus_interface_vtable = {client_private_dbus_interface_method_call, client_private_dbus_interface_get_property, client_private_dbus_interface_set_property};
static const JSClassDefinition PANEL_SESSION_MANAGER_js_class = {0, kJSClassAttributeNone, "SessionManager", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, _panel_session_manager_js_constructor_js_core_object_call_as_constructor_callback, NULL, NULL};

void session_manager_register_client (SessionManager* self, const gchar* app_id, const gchar* startup_id, char** path, GError** error) {
	g_return_if_fail (self != NULL);
	SESSION_MANAGER_GET_INTERFACE (self)->register_client (self, app_id, startup_id, path, error);
}


void session_manager_shutdown (SessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SESSION_MANAGER_GET_INTERFACE (self)->shutdown (self, _callback_, _user_data_);
}


void session_manager_shutdown_finish (SessionManager* self, GAsyncResult* _res_, GError** error) {
	SESSION_MANAGER_GET_INTERFACE (self)->shutdown_finish (self, _res_, error);
}


void session_manager_logout (SessionManager* self, guint32 mode, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SESSION_MANAGER_GET_INTERFACE (self)->logout (self, mode, _callback_, _user_data_);
}


void session_manager_logout_finish (SessionManager* self, GAsyncResult* _res_, GError** error) {
	SESSION_MANAGER_GET_INTERFACE (self)->logout_finish (self, _res_, error);
}


gboolean session_manager_can_shutdown (SessionManager* self, GError** error) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SESSION_MANAGER_GET_INTERFACE (self)->can_shutdown (self, error);
}


static void session_manager_base_init (SessionManagerIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType session_manager_get_type (void) {
	static volatile gsize session_manager_type_id__volatile = 0;
	if (g_once_init_enter (&session_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SessionManagerIface), (GBaseInitFunc) session_manager_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType session_manager_type_id;
		session_manager_type_id = g_type_register_static (G_TYPE_INTERFACE, "SessionManager", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (session_manager_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (session_manager_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) session_manager_proxy_get_type);
		g_type_set_qdata (session_manager_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.gnome.SessionManager");
		g_type_set_qdata (session_manager_type_id, g_quark_from_static_string ("vala-dbus-interface-info"), (void*) (&_session_manager_dbus_interface_info));
		g_type_set_qdata (session_manager_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) session_manager_register_object);
		g_once_init_leave (&session_manager_type_id__volatile, session_manager_type_id);
	}
	return session_manager_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (SessionManagerProxy, session_manager_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_SESSION_MANAGER, session_manager_proxy_session_manager_interface_init) )
static void session_manager_proxy_class_init (SessionManagerProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = session_manager_proxy_g_signal;
}


static void session_manager_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
}


static void session_manager_proxy_init (SessionManagerProxy* self) {
}


static void session_manager_proxy_register_client (SessionManager* self, const gchar* app_id, const gchar* startup_id, char** path, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	char* _vala_path;
	GVariant* _tmp0_;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.SessionManager", "RegisterClient");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (app_id));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (startup_id));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp0_ = g_variant_iter_next_value (&_reply_iter);
	_vala_path = g_variant_dup_string (_tmp0_, NULL);
	g_variant_unref (_tmp0_);
	*path = _vala_path;
	g_object_unref (_reply_message);
}


static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data) {
	g_simple_async_result_set_op_res_gpointer (user_data, g_object_ref (res), g_object_unref);
	g_simple_async_result_complete (user_data);
	g_object_unref (user_data);
}


static void session_manager_proxy_shutdown_async (SessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.SessionManager", "Shutdown");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
	g_object_unref (_message);
}


static void session_manager_proxy_shutdown_finish (SessionManager* self, GAsyncResult* _res_, GError** error) {
	GDBusMessage *_reply_message;
	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void session_manager_proxy_logout_async (SessionManager* self, guint32 mode, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.SessionManager", "Logout");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (mode));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
	g_object_unref (_message);
}


static void session_manager_proxy_logout_finish (SessionManager* self, GAsyncResult* _res_, GError** error) {
	GDBusMessage *_reply_message;
	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static gboolean session_manager_proxy_can_shutdown (SessionManager* self, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gboolean _result;
	GVariant* _tmp1_;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.SessionManager", "CanShutdown");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return FALSE;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return FALSE;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp1_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_get_boolean (_tmp1_);
	g_variant_unref (_tmp1_);
	g_object_unref (_reply_message);
	return _result;
}


static void session_manager_proxy_session_manager_interface_init (SessionManagerIface* iface) {
	iface->register_client = session_manager_proxy_register_client;
	iface->shutdown = session_manager_proxy_shutdown_async;
	iface->shutdown_finish = session_manager_proxy_shutdown_finish;
	iface->logout = session_manager_proxy_logout_async;
	iface->logout_finish = session_manager_proxy_logout_finish;
	iface->can_shutdown = session_manager_proxy_can_shutdown;
}


static void _dbus_session_manager_register_client (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* app_id = NULL;
	GVariant* _tmp2_;
	gchar* startup_id = NULL;
	GVariant* _tmp3_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	char* path = NULL;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp2_ = g_variant_iter_next_value (&_arguments_iter);
	app_id = g_variant_dup_string (_tmp2_, NULL);
	g_variant_unref (_tmp2_);
	_tmp3_ = g_variant_iter_next_value (&_arguments_iter);
	startup_id = g_variant_dup_string (_tmp3_, NULL);
	g_variant_unref (_tmp3_);
	session_manager_register_client (self, app_id, startup_id, &path, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_object_path (path));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (app_id);
	_g_free0 (startup_id);
	_g_free0 (path);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_session_manager_shutdown (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	session_manager_shutdown (self, (GAsyncReadyCallback) _dbus_session_manager_shutdown_ready, invocation);
}


static void _dbus_session_manager_shutdown_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	session_manager_shutdown_finish ((SessionManager*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_session_manager_logout (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	guint32 mode = 0U;
	GVariant* _tmp4_;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp4_ = g_variant_iter_next_value (&_arguments_iter);
	mode = g_variant_get_uint32 (_tmp4_);
	g_variant_unref (_tmp4_);
	session_manager_logout (self, mode, (GAsyncReadyCallback) _dbus_session_manager_logout_ready, invocation);
}


static void _dbus_session_manager_logout_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	session_manager_logout_finish ((SessionManager*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_session_manager_can_shutdown (SessionManager* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	result = session_manager_can_shutdown (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void session_manager_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "RegisterClient") == 0) {
		_dbus_session_manager_register_client (object, parameters, invocation);
	} else if (strcmp (method_name, "Shutdown") == 0) {
		_dbus_session_manager_shutdown (object, parameters, invocation);
	} else if (strcmp (method_name, "Logout") == 0) {
		_dbus_session_manager_logout (object, parameters, invocation);
	} else if (strcmp (method_name, "CanShutdown") == 0) {
		_dbus_session_manager_can_shutdown (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* session_manager_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean session_manager_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint session_manager_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_session_manager_dbus_interface_info), &_session_manager_dbus_interface_vtable, data, _session_manager_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _session_manager_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


void client_private_end_session_response (ClientPrivate* self, gboolean ok, const gchar* reason, GError** error) {
	g_return_if_fail (self != NULL);
	CLIENT_PRIVATE_GET_INTERFACE (self)->end_session_response (self, ok, reason, error);
}


static void client_private_base_init (ClientPrivateIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("query_end_session", TYPE_CLIENT_PRIVATE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__UINT, G_TYPE_NONE, 1, G_TYPE_UINT);
		g_signal_new ("end_session", TYPE_CLIENT_PRIVATE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__UINT, G_TYPE_NONE, 1, G_TYPE_UINT);
	}
}


GType client_private_get_type (void) {
	static volatile gsize client_private_type_id__volatile = 0;
	if (g_once_init_enter (&client_private_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClientPrivateIface), (GBaseInitFunc) client_private_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType client_private_type_id;
		client_private_type_id = g_type_register_static (G_TYPE_INTERFACE, "ClientPrivate", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (client_private_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (client_private_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) client_private_proxy_get_type);
		g_type_set_qdata (client_private_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.gnome.SessionManager.ClientPrivate");
		g_type_set_qdata (client_private_type_id, g_quark_from_static_string ("vala-dbus-interface-info"), (void*) (&_client_private_dbus_interface_info));
		g_type_set_qdata (client_private_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) client_private_register_object);
		g_once_init_leave (&client_private_type_id__volatile, client_private_type_id);
	}
	return client_private_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (ClientPrivateProxy, client_private_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_CLIENT_PRIVATE, client_private_proxy_client_private_interface_init) )
static void client_private_proxy_class_init (ClientPrivateProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = client_private_proxy_g_signal;
}


static void _dbus_handle_client_private_query_end_session (ClientPrivate* self, GVariant* parameters) {
	GVariantIter _arguments_iter;
	guint flags = 0U;
	GVariant* _tmp5_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp5_ = g_variant_iter_next_value (&_arguments_iter);
	flags = g_variant_get_uint32 (_tmp5_);
	g_variant_unref (_tmp5_);
	g_signal_emit_by_name (self, "query-end-session", flags);
}


static void _dbus_handle_client_private_end_session (ClientPrivate* self, GVariant* parameters) {
	GVariantIter _arguments_iter;
	guint flags = 0U;
	GVariant* _tmp6_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp6_ = g_variant_iter_next_value (&_arguments_iter);
	flags = g_variant_get_uint32 (_tmp6_);
	g_variant_unref (_tmp6_);
	g_signal_emit_by_name (self, "end-session", flags);
}


static void client_private_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
	if (strcmp (signal_name, "QueryEndSession") == 0) {
		_dbus_handle_client_private_query_end_session ((ClientPrivate*) proxy, parameters);
	} else if (strcmp (signal_name, "EndSession") == 0) {
		_dbus_handle_client_private_end_session ((ClientPrivate*) proxy, parameters);
	}
}


static void client_private_proxy_init (ClientPrivateProxy* self) {
}


static void client_private_proxy_end_session_response (ClientPrivate* self, gboolean ok, const gchar* reason, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.SessionManager.ClientPrivate", "EndSessionResponse");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (ok));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (reason));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void client_private_proxy_client_private_interface_init (ClientPrivateIface* iface) {
	iface->end_session_response = client_private_proxy_end_session_response;
}


static void _dbus_client_private_end_session_response (ClientPrivate* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gboolean ok = FALSE;
	GVariant* _tmp7_;
	gchar* reason = NULL;
	GVariant* _tmp8_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp7_ = g_variant_iter_next_value (&_arguments_iter);
	ok = g_variant_get_boolean (_tmp7_);
	g_variant_unref (_tmp7_);
	_tmp8_ = g_variant_iter_next_value (&_arguments_iter);
	reason = g_variant_dup_string (_tmp8_, NULL);
	g_variant_unref (_tmp8_);
	client_private_end_session_response (self, ok, reason, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (reason);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void client_private_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "EndSessionResponse") == 0) {
		_dbus_client_private_end_session_response (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* client_private_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean client_private_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_client_private_query_end_session (GObject* _sender, guint flags, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (flags));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.SessionManager.ClientPrivate", "QueryEndSession", _arguments, NULL);
}


static void _dbus_client_private_end_session (GObject* _sender, guint flags, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (flags));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.SessionManager.ClientPrivate", "EndSession", _arguments, NULL);
}


guint client_private_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_client_private_dbus_interface_info), &_client_private_dbus_interface_vtable, data, _client_private_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "query-end-session", (GCallback) _dbus_client_private_query_end_session, data);
	g_signal_connect (object, "end-session", (GCallback) _dbus_client_private_end_session, data);
	return result;
}


static void _client_private_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_signal_handlers_disconnect_by_func (data[0], _dbus_client_private_query_end_session, data);
	g_signal_handlers_disconnect_by_func (data[0], _dbus_client_private_end_session, data);
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static void* _panel_session_manager_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = panel_session_manager_js_constructor (ctx, constructor, arguments, arguments_length1, exception);
	return result;
}


static gpointer _panel_session_manager_ref0 (gpointer self) {
	return self ? panel_session_manager_ref (self) : NULL;
}


PanelSessionManager* panel_session_manager_getInstance (void) {
	PanelSessionManager* result = NULL;
	PanelSessionManager* _tmp0_ = NULL;
	PanelSessionManager* _tmp2_ = NULL;
	PanelSessionManager* _tmp3_ = NULL;
	_tmp0_ = panel_session_manager_instance;
	if (_tmp0_ == NULL) {
		PanelSessionManager* _tmp1_ = NULL;
		_tmp1_ = panel_session_manager_new ();
		_panel_session_manager_unref0 (panel_session_manager_instance);
		panel_session_manager_instance = _tmp1_;
	}
	_tmp2_ = panel_session_manager_instance;
	_tmp3_ = _panel_session_manager_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


static PanelSessionManager* panel_session_manager_construct (GType object_type) {
	PanelSessionManager* self = NULL;
	const char* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	self = (PanelSessionManager*) g_type_create_instance (object_type);
	{
		SessionManager* _tmp0_ = NULL;
		SessionManager* _tmp1_ = NULL;
		SessionManager* _tmp2_ = NULL;
		_tmp1_ = g_initable_new (TYPE_SESSION_MANAGER_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.gnome.SessionManager", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/gnome/SessionManager", "g-interface-name", "org.gnome.SessionManager", "g-interface-info", g_type_get_qdata (TYPE_SESSION_MANAGER, g_quark_from_static_string ("vala-dbus-interface-info")), NULL);
		_tmp0_ = (SessionManager*) _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch11_g_error;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (self->priv->session);
		self->priv->session = _tmp2_;
		_g_object_unref0 (_tmp0_);
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError* e = NULL;
		FILE* _tmp3_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = stderr;
		fprintf (_tmp3_, "Unable to connect to session manager\n");
		_g_error_free0 (e);
	}
	__finally11:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = panel_session_manager_session_id;
	if (_tmp4_ == NULL) {
		panel_session_manager_register (self);
	}
	return self;
}


static PanelSessionManager* panel_session_manager_new (void) {
	return panel_session_manager_construct (TYPE_PANEL_SESSION_MANAGER);
}


static void _____lambda9_ (PanelSessionManager* self, guint flags) {
	panel_session_manager_send_end_response (self);
	gtk_main_quit ();
}


static void ______lambda9__client_private_end_session (ClientPrivate* _sender, guint flags, gpointer self) {
	_____lambda9_ ((PanelSessionManager*) self, flags);
}


static void _____lambda10_ (PanelSessionManager* self, guint flags) {
	panel_session_manager_send_end_response (self);
}


static void ______lambda10__client_private_query_end_session (ClientPrivate* _sender, guint flags, gpointer self) {
	_____lambda10_ ((PanelSessionManager*) self, flags);
}


void panel_session_manager_register (PanelSessionManager* self) {
	SessionManager* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->session;
	if (_tmp0_ != NULL) {
		{
			gchar* id = NULL;
			const gchar* _tmp1_ = NULL;
			gchar* _tmp2_ = NULL;
			const gchar* _tmp3_ = NULL;
			_tmp1_ = g_getenv ("DESKTOP_AUTOSTART_ID");
			_tmp2_ = g_strdup (_tmp1_);
			id = _tmp2_;
			_tmp3_ = id;
			if (_tmp3_ != NULL) {
				SessionManager* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				char* _tmp6_ = NULL;
				ClientPrivate* _tmp7_ = NULL;
				const char* _tmp8_ = NULL;
				ClientPrivate* _tmp9_ = NULL;
				ClientPrivate* _tmp10_ = NULL;
				ClientPrivate* _tmp11_ = NULL;
				ClientPrivate* _tmp12_ = NULL;
				_tmp4_ = self->priv->session;
				_tmp5_ = id;
				session_manager_register_client (_tmp4_, "manokwari", _tmp5_, &_tmp6_, &_inner_error_);
				_g_free0 (panel_session_manager_session_id);
				panel_session_manager_session_id = _tmp6_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_free0 (id);
					goto __catch12_g_error;
				}
				_tmp8_ = panel_session_manager_session_id;
				_tmp9_ = g_initable_new (TYPE_CLIENT_PRIVATE_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.gnome.SessionManager", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", (const gchar*) _tmp8_, "g-interface-name", "org.gnome.SessionManager.ClientPrivate", "g-interface-info", g_type_get_qdata (TYPE_CLIENT_PRIVATE, g_quark_from_static_string ("vala-dbus-interface-info")), NULL);
				_tmp7_ = (ClientPrivate*) _tmp9_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_free0 (id);
					goto __catch12_g_error;
				}
				_tmp10_ = _tmp7_;
				_tmp7_ = NULL;
				_g_object_unref0 (self->priv->client);
				self->priv->client = _tmp10_;
				_tmp11_ = self->priv->client;
				g_signal_connect (_tmp11_, "end-session", (GCallback) ______lambda9__client_private_end_session, self);
				_tmp12_ = self->priv->client;
				g_signal_connect (_tmp12_, "query-end-session", (GCallback) ______lambda10__client_private_query_end_session, self);
				_g_object_unref0 (_tmp7_);
			}
			_g_free0 (id);
		}
		goto __finally12;
		__catch12_g_error:
		{
			GError* e = NULL;
			FILE* _tmp13_ = NULL;
			GError* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp13_ = stderr;
			_tmp14_ = e;
			_tmp15_ = _tmp14_->message;
			fprintf (_tmp13_, "Unable to register session: %s\n", _tmp15_);
			_g_error_free0 (e);
		}
		__finally12:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


static void panel_session_manager_send_end_response (PanelSessionManager* self) {
	ClientPrivate* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->client;
	if (_tmp0_ != NULL) {
		{
			ClientPrivate* _tmp1_ = NULL;
			_tmp1_ = self->priv->client;
			client_private_end_session_response (_tmp1_, TRUE, "", &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == G_IO_ERROR) {
					goto __catch13_g_io_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally13;
		__catch13_g_io_error:
		{
			GError* e = NULL;
			FILE* _tmp2_ = NULL;
			GError* _tmp3_ = NULL;
			const gchar* _tmp4_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp2_ = stderr;
			_tmp3_ = e;
			_tmp4_ = _tmp3_->message;
			fprintf (_tmp2_, "Unable to send data to session manager: %s\n", _tmp4_);
			_g_error_free0 (e);
		}
		__finally13:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


static void panel_session_manager_logout_data_free (gpointer _data) {
	PanelSessionManagerLogoutData* _data_;
	_data_ = _data;
	_panel_session_manager_unref0 (_data_->self);
	g_slice_free (PanelSessionManagerLogoutData, _data_);
}


void panel_session_manager_logout (PanelSessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PanelSessionManagerLogoutData* _data_;
	PanelSessionManager* _tmp0_ = NULL;
	_data_ = g_slice_new0 (PanelSessionManagerLogoutData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, panel_session_manager_logout);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, panel_session_manager_logout_data_free);
	_tmp0_ = _panel_session_manager_ref0 (self);
	_data_->self = _tmp0_;
	panel_session_manager_logout_co (_data_);
}


void panel_session_manager_logout_finish (PanelSessionManager* self, GAsyncResult* _res_) {
	PanelSessionManagerLogoutData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean panel_session_manager_logout_co (PanelSessionManagerLogoutData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->session;
	if (_data_->_tmp0_ != NULL) {
		{
			_data_->_tmp1_ = NULL;
			_data_->_tmp1_ = _data_->self->priv->session;
			session_manager_logout (_data_->_tmp1_, (guint32) 0, NULL, NULL);
		}
		goto __finally14;
		__catch14_g_error:
		{
			_data_->e = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp2_ = NULL;
			_data_->_tmp2_ = stderr;
			_data_->_tmp3_ = NULL;
			_data_->_tmp3_ = _data_->e;
			_data_->_tmp4_ = NULL;
			_data_->_tmp4_ = _data_->_tmp3_->message;
			fprintf (_data_->_tmp2_, "Unable to logout: %s\n", _data_->_tmp4_);
			_g_error_free0 (_data_->e);
		}
		__finally14:
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void panel_session_manager_shutdown_data_free (gpointer _data) {
	PanelSessionManagerShutdownData* _data_;
	_data_ = _data;
	_panel_session_manager_unref0 (_data_->self);
	g_slice_free (PanelSessionManagerShutdownData, _data_);
}


void panel_session_manager_shutdown (PanelSessionManager* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PanelSessionManagerShutdownData* _data_;
	PanelSessionManager* _tmp0_ = NULL;
	_data_ = g_slice_new0 (PanelSessionManagerShutdownData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, panel_session_manager_shutdown);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, panel_session_manager_shutdown_data_free);
	_tmp0_ = _panel_session_manager_ref0 (self);
	_data_->self = _tmp0_;
	panel_session_manager_shutdown_co (_data_);
}


void panel_session_manager_shutdown_finish (PanelSessionManager* self, GAsyncResult* _res_) {
	PanelSessionManagerShutdownData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean panel_session_manager_shutdown_co (PanelSessionManagerShutdownData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->session;
	if (_data_->_tmp0_ != NULL) {
		{
			_data_->_tmp1_ = NULL;
			_data_->_tmp1_ = _data_->self->priv->session;
			session_manager_shutdown (_data_->_tmp1_, NULL, NULL);
		}
		goto __finally15;
		__catch15_g_error:
		{
			_data_->e = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp2_ = NULL;
			_data_->_tmp2_ = stderr;
			_data_->_tmp3_ = NULL;
			_data_->_tmp3_ = _data_->e;
			_data_->_tmp4_ = NULL;
			_data_->_tmp4_ = _data_->_tmp3_->message;
			fprintf (_data_->_tmp2_, "Unable to shutdown: %s\n", _data_->_tmp4_);
			_g_error_free0 (_data_->e);
		}
		__finally15:
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


gboolean panel_session_manager_can_shutdown (PanelSessionManager* self) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		SessionManager* _tmp0_ = NULL;
		_tmp0_ = self->priv->session;
		session_manager_can_shutdown (_tmp0_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch16_g_error;
		}
		result = TRUE;
		return result;
	}
	goto __finally16;
	__catch16_g_error:
	{
		GError* e = NULL;
		FILE* _tmp1_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp1_ = stdout;
		fprintf (_tmp1_, "Unable to shutdown\n");
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally16:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static void* _panel_session_manager_js_can_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = panel_session_manager_js_can_shutdown (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _panel_session_manager_js_logout_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = panel_session_manager_js_logout (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _panel_session_manager_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = panel_session_manager_js_shutdown (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


void* panel_session_manager_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* s = NULL;
	void* _tmp3_ = NULL;
	void* f = NULL;
	void* _tmp4_ = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	void* _tmp8_ = NULL;
	void* _tmp9_ = NULL;
	void* _tmp10_ = NULL;
	void* _tmp11_ = NULL;
	void* _tmp12_ = NULL;
	void* _tmp13_ = NULL;
	void* _tmp14_ = NULL;
	void* _tmp15_ = NULL;
	void* _tmp16_ = NULL;
	void* _tmp17_ = NULL;
	void* _tmp18_ = NULL;
	void* _tmp19_ = NULL;
	void* _tmp20_ = NULL;
	void* _tmp21_ = NULL;
	void* _tmp22_ = NULL;
	void* _tmp23_ = NULL;
	PanelSessionManager* i = NULL;
	PanelSessionManager* _tmp24_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (constructor != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = JSClassCreate (&PANEL_SESSION_MANAGER_js_class);
	c = _tmp0_;
	_tmp1_ = ctx;
	_tmp2_ = JSObjectMake (_tmp1_, c, NULL);
	o = _tmp2_;
	_tmp3_ = JSStringCreateWithUTF8CString ("canShutdown");
	s = _tmp3_;
	_tmp4_ = ctx;
	_tmp5_ = s;
	_tmp6_ = JSObjectMakeFunctionWithCallback (_tmp4_, _tmp5_, _panel_session_manager_js_can_shutdown_js_core_object_call_as_function_callback);
	f = _tmp6_;
	_tmp7_ = ctx;
	_tmp8_ = s;
	_tmp9_ = f;
	JSObjectSetProperty (_tmp7_, o, _tmp8_, _tmp9_, 0, NULL);
	_tmp10_ = JSStringCreateWithUTF8CString ("logout");
	_JSStringRelease0 (s);
	s = _tmp10_;
	_tmp11_ = ctx;
	_tmp12_ = s;
	_tmp13_ = JSObjectMakeFunctionWithCallback (_tmp11_, _tmp12_, _panel_session_manager_js_logout_js_core_object_call_as_function_callback);
	_0 (f);
	f = _tmp13_;
	_tmp14_ = ctx;
	_tmp15_ = s;
	_tmp16_ = f;
	JSObjectSetProperty (_tmp14_, o, _tmp15_, _tmp16_, 0, NULL);
	_tmp17_ = JSStringCreateWithUTF8CString ("shutdown");
	_JSStringRelease0 (s);
	s = _tmp17_;
	_tmp18_ = ctx;
	_tmp19_ = s;
	_tmp20_ = JSObjectMakeFunctionWithCallback (_tmp18_, _tmp19_, _panel_session_manager_js_shutdown_js_core_object_call_as_function_callback);
	_0 (f);
	f = _tmp20_;
	_tmp21_ = ctx;
	_tmp22_ = s;
	_tmp23_ = f;
	JSObjectSetProperty (_tmp21_, o, _tmp22_, _tmp23_, 0, NULL);
	_tmp24_ = panel_session_manager_getInstance ();
	i = _tmp24_;
	JSObjectSetPrivate (o, i);
	result = o;
	_0 (f);
	_JSStringRelease0 (s);
	_JSClassRelease0 (c);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* panel_session_manager_js_can_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	PanelSessionManager* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	PanelSessionManager* _tmp2_ = NULL;
	PanelSessionManager* _tmp3_ = NULL;
	void* _tmp8_ = NULL;
	void* _tmp9_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _panel_session_manager_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_PANEL_SESSION_MANAGER) ? ((PanelSessionManager*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		void* _tmp4_ = NULL;
		PanelSessionManager* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		void* _tmp7_ = NULL;
		_tmp4_ = ctx;
		_tmp5_ = i;
		_tmp6_ = panel_session_manager_can_shutdown (_tmp5_);
		_tmp7_ = JSValueMakeBoolean (_tmp4_, _tmp6_);
		result = _tmp7_;
		_panel_session_manager_unref0 (i);
		if (exception) {
			*exception = _vala_exception;
		} else {
			_0 (_vala_exception);
		}
		return result;
	}
	_tmp8_ = ctx;
	_tmp9_ = JSValueMakeUndefined (_tmp8_);
	result = _tmp9_;
	_panel_session_manager_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* panel_session_manager_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	PanelSessionManager* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	PanelSessionManager* _tmp2_ = NULL;
	PanelSessionManager* _tmp3_ = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _panel_session_manager_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_PANEL_SESSION_MANAGER) ? ((PanelSessionManager*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		PanelSessionManager* _tmp4_ = NULL;
		_tmp4_ = i;
		panel_session_manager_shutdown (_tmp4_, NULL, NULL);
	}
	_tmp5_ = ctx;
	_tmp6_ = JSValueMakeUndefined (_tmp5_);
	result = _tmp6_;
	_panel_session_manager_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* panel_session_manager_js_logout (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	PanelSessionManager* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	PanelSessionManager* _tmp2_ = NULL;
	PanelSessionManager* _tmp3_ = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _panel_session_manager_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_PANEL_SESSION_MANAGER) ? ((PanelSessionManager*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		PanelSessionManager* _tmp4_ = NULL;
		_tmp4_ = i;
		panel_session_manager_logout (_tmp4_, NULL, NULL);
	}
	_tmp5_ = ctx;
	_tmp6_ = JSValueMakeUndefined (_tmp5_);
	result = _tmp6_;
	_panel_session_manager_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void panel_session_manager_setup_js_class (void* context) {
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* g = NULL;
	void* _tmp4_ = NULL;
	void* _tmp5_ = NULL;
	void* s = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	g_return_if_fail (context != NULL);
	_tmp0_ = JSClassCreate (&PANEL_SESSION_MANAGER_js_class);
	c = _tmp0_;
	_tmp1_ = context;
	_tmp2_ = context;
	_tmp3_ = JSObjectMake (_tmp1_, c, _tmp2_);
	o = _tmp3_;
	_tmp4_ = context;
	_tmp5_ = JSContextGetGlobalObject (_tmp4_);
	g = _tmp5_;
	_tmp6_ = JSStringCreateWithUTF8CString ("SessionManager");
	s = _tmp6_;
	_tmp7_ = context;
	JSObjectSetProperty (_tmp7_, g, s, o, kJSPropertyAttributeNone, NULL);
	_JSStringRelease0 (s);
	_0 (g);
	_0 (o);
	_JSClassRelease0 (c);
}


static void value_panel_session_manager_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_panel_session_manager_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		panel_session_manager_unref (value->data[0].v_pointer);
	}
}


static void value_panel_session_manager_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = panel_session_manager_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_panel_session_manager_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_panel_session_manager_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		PanelSessionManager* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = panel_session_manager_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_panel_session_manager_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	PanelSessionManager** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = panel_session_manager_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_panel_session_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecPanelSessionManager* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PANEL_SESSION_MANAGER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_panel_session_manager (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PANEL_SESSION_MANAGER), NULL);
	return value->data[0].v_pointer;
}


void value_set_panel_session_manager (GValue* value, gpointer v_object) {
	PanelSessionManager* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PANEL_SESSION_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PANEL_SESSION_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		panel_session_manager_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panel_session_manager_unref (old);
	}
}


void value_take_panel_session_manager (GValue* value, gpointer v_object) {
	PanelSessionManager* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PANEL_SESSION_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PANEL_SESSION_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panel_session_manager_unref (old);
	}
}


static void panel_session_manager_class_init (PanelSessionManagerClass * klass) {
	panel_session_manager_parent_class = g_type_class_peek_parent (klass);
	((PanelSessionManagerClass *) klass)->finalize = panel_session_manager_finalize;
	g_type_class_add_private (klass, sizeof (PanelSessionManagerPrivate));
}


static void panel_session_manager_instance_init (PanelSessionManager * self) {
	self->priv = PANEL_SESSION_MANAGER_GET_PRIVATE (self);
	self->priv->session = NULL;
	self->priv->client = NULL;
	self->ref_count = 1;
}


static void panel_session_manager_finalize (PanelSessionManager* obj) {
	PanelSessionManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_SESSION_MANAGER, PanelSessionManager);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->session);
	_g_object_unref0 (self->priv->client);
}


GType panel_session_manager_get_type (void) {
	static volatile gsize panel_session_manager_type_id__volatile = 0;
	if (g_once_init_enter (&panel_session_manager_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_panel_session_manager_init, value_panel_session_manager_free_value, value_panel_session_manager_copy_value, value_panel_session_manager_peek_pointer, "p", value_panel_session_manager_collect_value, "p", value_panel_session_manager_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PanelSessionManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_session_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelSessionManager), 0, (GInstanceInitFunc) panel_session_manager_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType panel_session_manager_type_id;
		panel_session_manager_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PanelSessionManager", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&panel_session_manager_type_id__volatile, panel_session_manager_type_id);
	}
	return panel_session_manager_type_id__volatile;
}


gpointer panel_session_manager_ref (gpointer instance) {
	PanelSessionManager* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void panel_session_manager_unref (gpointer instance) {
	PanelSessionManager* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PANEL_SESSION_MANAGER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



