/* panel-menu-content.c generated by valac 0.26.1, the Vala compiler
 * generated from panel-menu-content.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_PANEL_MENU_CONTENT (panel_menu_content_get_type ())
#define PANEL_MENU_CONTENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_MENU_CONTENT, PanelMenuContent))
#define PANEL_MENU_CONTENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_MENU_CONTENT, PanelMenuContentClass))
#define IS_PANEL_MENU_CONTENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_MENU_CONTENT))
#define IS_PANEL_MENU_CONTENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_MENU_CONTENT))
#define PANEL_MENU_CONTENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_MENU_CONTENT, PanelMenuContentClass))

typedef struct _PanelMenuContent PanelMenuContent;
typedef struct _PanelMenuContentClass PanelMenuContentClass;
typedef struct _PanelMenuContentPrivate PanelMenuContentPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _PanelMenuContent {
	GtkVBox parent_instance;
	PanelMenuContentPrivate * priv;
	GtkVBox* bar;
};

struct _PanelMenuContentClass {
	GtkVBoxClass parent_class;
};


static gpointer panel_menu_content_parent_class = NULL;

GType panel_menu_content_get_type (void) G_GNUC_CONST;
enum  {
	PANEL_MENU_CONTENT_DUMMY_PROPERTY
};
PanelMenuContent* panel_menu_content_new (const gchar* label);
PanelMenuContent* panel_menu_content_construct (GType object_type, const gchar* label);
static void panel_menu_content_real_get_preferred_width (GtkWidget* base, gint* min, gint* max);
void panel_menu_content_insert_separator (PanelMenuContent* self);
static void panel_menu_content_finalize (GObject* obj);


PanelMenuContent* panel_menu_content_construct (GType object_type, const gchar* label) {
	PanelMenuContent * self = NULL;
	const gchar* _tmp0_ = NULL;
	self = (PanelMenuContent*) g_object_new (object_type, NULL);
	_tmp0_ = label;
	if (_tmp0_ != NULL) {
		GtkLabel* l = NULL;
		GtkLabel* _tmp1_ = NULL;
		GtkLabel* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		GtkLabel* _tmp8_ = NULL;
		GtkLabel* _tmp9_ = NULL;
		_tmp1_ = (GtkLabel*) gtk_label_new ("");
		g_object_ref_sink (_tmp1_);
		l = _tmp1_;
		_tmp2_ = l;
		_tmp3_ = label;
		_tmp4_ = g_strconcat ("<big>\n", _tmp3_, NULL);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat (_tmp5_, "</big>", NULL);
		_tmp7_ = _tmp6_;
		gtk_label_set_markup (_tmp2_, _tmp7_);
		_g_free0 (_tmp7_);
		_g_free0 (_tmp5_);
		_tmp8_ = l;
		gtk_widget_show ((GtkWidget*) _tmp8_);
		_tmp9_ = l;
		gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp9_, FALSE, FALSE, (guint) 5);
		_g_object_unref0 (l);
	}
	gtk_widget_show_all ((GtkWidget*) self);
	return self;
}


PanelMenuContent* panel_menu_content_new (const gchar* label) {
	return panel_menu_content_construct (TYPE_PANEL_MENU_CONTENT, label);
}


static void panel_menu_content_real_get_preferred_width (GtkWidget* base, gint* min, gint* max) {
	PanelMenuContent * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	self = (PanelMenuContent*) base;
	_vala_max = 250;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


void panel_menu_content_insert_separator (PanelMenuContent* self) {
	GtkSeparator* separator = NULL;
	GtkSeparator* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkSeparator*) gtk_separator_new (GTK_ORIENTATION_HORIZONTAL);
	g_object_ref_sink (_tmp0_);
	separator = _tmp0_;
	gtk_widget_show ((GtkWidget*) separator);
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) separator, FALSE, FALSE, (guint) 10);
	_g_object_unref0 (separator);
}


static void panel_menu_content_class_init (PanelMenuContentClass * klass) {
	panel_menu_content_parent_class = g_type_class_peek_parent (klass);
	((GtkWidgetClass *) klass)->get_preferred_width = panel_menu_content_real_get_preferred_width;
	G_OBJECT_CLASS (klass)->finalize = panel_menu_content_finalize;
	g_signal_new ("menu_clicked", TYPE_PANEL_MENU_CONTENT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void panel_menu_content_instance_init (PanelMenuContent * self) {
}


static void panel_menu_content_finalize (GObject* obj) {
	PanelMenuContent * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_MENU_CONTENT, PanelMenuContent);
	_g_object_unref0 (self->bar);
	G_OBJECT_CLASS (panel_menu_content_parent_class)->finalize (obj);
}


GType panel_menu_content_get_type (void) {
	static volatile gsize panel_menu_content_type_id__volatile = 0;
	if (g_once_init_enter (&panel_menu_content_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelMenuContentClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_menu_content_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelMenuContent), 0, (GInstanceInitFunc) panel_menu_content_instance_init, NULL };
		GType panel_menu_content_type_id;
		panel_menu_content_type_id = g_type_register_static (GTK_TYPE_VBOX, "PanelMenuContent", &g_define_type_info, 0);
		g_once_init_leave (&panel_menu_content_type_id__volatile, panel_menu_content_type_id);
	}
	return panel_menu_content_type_id__volatile;
}



