/* panel-window.c generated by valac 0.26.1, the Vala compiler
 * generated from panel-window.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <libwnck/libwnck.h>
#include <glib/gi18n-lib.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <stdio.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <pango/pango.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_PANEL_ABSTRACT_WINDOW (panel_abstract_window_get_type ())
#define PANEL_ABSTRACT_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_ABSTRACT_WINDOW, PanelAbstractWindow))
#define PANEL_ABSTRACT_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_ABSTRACT_WINDOW, PanelAbstractWindowClass))
#define IS_PANEL_ABSTRACT_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_ABSTRACT_WINDOW))
#define IS_PANEL_ABSTRACT_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_ABSTRACT_WINDOW))
#define PANEL_ABSTRACT_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_ABSTRACT_WINDOW, PanelAbstractWindowClass))

typedef struct _PanelAbstractWindow PanelAbstractWindow;
typedef struct _PanelAbstractWindowClass PanelAbstractWindowClass;
typedef struct _PanelAbstractWindowPrivate PanelAbstractWindowPrivate;

#define TYPE_PANEL_WINDOW_PAGER (panel_window_pager_get_type ())
#define PANEL_WINDOW_PAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_WINDOW_PAGER, PanelWindowPager))
#define PANEL_WINDOW_PAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_WINDOW_PAGER, PanelWindowPagerClass))
#define IS_PANEL_WINDOW_PAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_WINDOW_PAGER))
#define IS_PANEL_WINDOW_PAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_WINDOW_PAGER))
#define PANEL_WINDOW_PAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_WINDOW_PAGER, PanelWindowPagerClass))

typedef struct _PanelWindowPager PanelWindowPager;
typedef struct _PanelWindowPagerClass PanelWindowPagerClass;
typedef struct _PanelWindowPagerPrivate PanelWindowPagerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_PANEL_WINDOW_PAGER_ENTRY (panel_window_pager_entry_get_type ())
#define PANEL_WINDOW_PAGER_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_WINDOW_PAGER_ENTRY, PanelWindowPagerEntry))
#define PANEL_WINDOW_PAGER_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_WINDOW_PAGER_ENTRY, PanelWindowPagerEntryClass))
#define IS_PANEL_WINDOW_PAGER_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_WINDOW_PAGER_ENTRY))
#define IS_PANEL_WINDOW_PAGER_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_WINDOW_PAGER_ENTRY))
#define PANEL_WINDOW_PAGER_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_WINDOW_PAGER_ENTRY, PanelWindowPagerEntryClass))

typedef struct _PanelWindowPagerEntry PanelWindowPagerEntry;
typedef struct _PanelWindowPagerEntryClass PanelWindowPagerEntryClass;
typedef struct _PanelWindowPagerEntryPrivate PanelWindowPagerEntryPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_PANEL_WINDOW_ENTRY (panel_window_entry_get_type ())
#define PANEL_WINDOW_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_WINDOW_ENTRY, PanelWindowEntry))
#define PANEL_WINDOW_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_WINDOW_ENTRY, PanelWindowEntryClass))
#define IS_PANEL_WINDOW_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_WINDOW_ENTRY))
#define IS_PANEL_WINDOW_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_WINDOW_ENTRY))
#define PANEL_WINDOW_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_WINDOW_ENTRY, PanelWindowEntryClass))

typedef struct _PanelWindowEntry PanelWindowEntry;
typedef struct _PanelWindowEntryClass PanelWindowEntryClass;
typedef struct _PanelWindowEntryPrivate PanelWindowEntryPrivate;

#define TYPE_PANEL_WINDOW_HOST (panel_window_host_get_type ())
#define PANEL_WINDOW_HOST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_WINDOW_HOST, PanelWindowHost))
#define PANEL_WINDOW_HOST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_WINDOW_HOST, PanelWindowHostClass))
#define IS_PANEL_WINDOW_HOST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_WINDOW_HOST))
#define IS_PANEL_WINDOW_HOST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_WINDOW_HOST))
#define PANEL_WINDOW_HOST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_WINDOW_HOST, PanelWindowHostClass))

typedef struct _PanelWindowHost PanelWindowHost;
typedef struct _PanelWindowHostClass PanelWindowHostClass;

#define TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS (panel_window_entry_descriptions_get_type ())
#define PANEL_WINDOW_ENTRY_DESCRIPTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, PanelWindowEntryDescriptions))
#define PANEL_WINDOW_ENTRY_DESCRIPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, PanelWindowEntryDescriptionsClass))
#define IS_PANEL_WINDOW_ENTRY_DESCRIPTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS))
#define IS_PANEL_WINDOW_ENTRY_DESCRIPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS))
#define PANEL_WINDOW_ENTRY_DESCRIPTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, PanelWindowEntryDescriptionsClass))

typedef struct _PanelWindowEntryDescriptions PanelWindowEntryDescriptions;
typedef struct _PanelWindowEntryDescriptionsClass PanelWindowEntryDescriptionsClass;
typedef struct _PanelWindowEntryDescriptionsPrivate PanelWindowEntryDescriptionsPrivate;

#define TYPE_ANIMATED_PROPERTY (animated_property_get_type ())
#define ANIMATED_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ANIMATED_PROPERTY, AnimatedProperty))
#define ANIMATED_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ANIMATED_PROPERTY, AnimatedPropertyClass))
#define IS_ANIMATED_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ANIMATED_PROPERTY))
#define IS_ANIMATED_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ANIMATED_PROPERTY))
#define ANIMATED_PROPERTY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ANIMATED_PROPERTY, AnimatedPropertyClass))

typedef struct _AnimatedProperty AnimatedProperty;
typedef struct _AnimatedPropertyClass AnimatedPropertyClass;
#define _animated_property_unref0(var) ((var == NULL) ? NULL : (var = (animated_property_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _PanelWindowHostPrivate PanelWindowHostPrivate;

#define TYPE_PANEL_TRAY (panel_tray_get_type ())
#define PANEL_TRAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_TRAY, PanelTray))
#define PANEL_TRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_TRAY, PanelTrayClass))
#define IS_PANEL_TRAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_TRAY))
#define IS_PANEL_TRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_TRAY))
#define PANEL_TRAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_TRAY, PanelTrayClass))

typedef struct _PanelTray PanelTray;
typedef struct _PanelTrayClass PanelTrayClass;

#define TYPE_PANEL_CALENDAR (panel_calendar_get_type ())
#define PANEL_CALENDAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_CALENDAR, PanelCalendar))
#define PANEL_CALENDAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_CALENDAR, PanelCalendarClass))
#define IS_PANEL_CALENDAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_CALENDAR))
#define IS_PANEL_CALENDAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_CALENDAR))
#define PANEL_CALENDAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_CALENDAR, PanelCalendarClass))

typedef struct _PanelCalendar PanelCalendar;
typedef struct _PanelCalendarClass PanelCalendarClass;
typedef struct _Block2Data Block2Data;

#define TYPE_PANEL_CLOCK (panel_clock_get_type ())
#define PANEL_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL_CLOCK, PanelClock))
#define PANEL_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL_CLOCK, PanelClockClass))
#define IS_PANEL_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL_CLOCK))
#define IS_PANEL_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL_CLOCK))
#define PANEL_CLOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL_CLOCK, PanelClockClass))

typedef struct _PanelClock PanelClock;
typedef struct _PanelClockClass PanelClockClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _Block3Data Block3Data;

struct _PanelAbstractWindow {
	GtkWindow parent_instance;
	PanelAbstractWindowPrivate * priv;
};

struct _PanelAbstractWindowClass {
	GtkWindowClass parent_class;
};

struct _PanelWindowPager {
	PanelAbstractWindow parent_instance;
	PanelWindowPagerPrivate * priv;
};

struct _PanelWindowPagerClass {
	PanelAbstractWindowClass parent_class;
};

struct _PanelWindowPagerPrivate {
	GtkToggleButton* desktop;
};

struct _PanelWindowPagerEntry {
	GtkDrawingArea parent_instance;
	PanelWindowPagerEntryPrivate * priv;
};

struct _PanelWindowPagerEntryClass {
	GtkDrawingAreaClass parent_class;
};

struct _PanelWindowPagerEntryPrivate {
	PanelWindowPager* pager;
	GdkPixbuf* icon;
};

struct _PanelWindowEntry {
	GtkDrawingArea parent_instance;
	PanelWindowEntryPrivate * priv;
	WnckWindow* window_info;
};

struct _PanelWindowEntryClass {
	GtkDrawingAreaClass parent_class;
};

struct _PanelWindowEntryPrivate {
	GdkPixbuf* icon;
	WnckWindowState last_state;
	GtkStateFlags state;
	gboolean popup_shown;
	PangoLayout* pango;
	gint Margin;
	gboolean oversize;
	gint iconWidth;
	gboolean _draw_info;
};

struct _PanelWindowEntryDescriptions {
	PanelAbstractWindow parent_instance;
	PanelWindowEntryDescriptionsPrivate * priv;
};

struct _PanelWindowEntryDescriptionsClass {
	PanelAbstractWindowClass parent_class;
};

struct _PanelWindowEntryDescriptionsPrivate {
	GeeArrayList* stack;
	GeeHashMap* entry_map;
	GeeHashMap* position_map;
	PanelWindowEntry* active_entry;
	PanelWindowEntry* old_entry;
	PangoLayout* pango;
	gint margin;
	gboolean hiding;
	AnimatedProperty* anim;
	gdouble _offset;
};

struct _PanelWindowHost {
	PanelAbstractWindow parent_instance;
	PanelWindowHostPrivate * priv;
};

struct _PanelWindowHostClass {
	PanelAbstractWindowClass parent_class;
};

struct _PanelWindowHostPrivate {
	GtkImage* logo;
	gboolean active;
	GtkHBox* box;
	PanelTray* tray;
	WnckScreen* screen;
	gint num_visible_windows;
	GeeHashMap* entry_map;
	gint height;
	PanelWindowEntryDescriptions* descriptions;
	PanelCalendar* calendar;
};

struct _Block2Data {
	int _ref_count_;
	PanelWindowHost* self;
	PanelWindowPagerEntry* pager_entry;
};

struct _Block3Data {
	int _ref_count_;
	PanelWindowHost* self;
	PanelWindowEntry* e;
};


static gpointer panel_window_pager_parent_class = NULL;
static gpointer panel_window_pager_entry_parent_class = NULL;
static gpointer panel_window_entry_parent_class = NULL;
static gpointer panel_window_entry_descriptions_parent_class = NULL;
static gpointer panel_window_host_parent_class = NULL;

GType panel_abstract_window_get_type (void) G_GNUC_CONST;
GType panel_window_pager_get_type (void) G_GNUC_CONST;
#define PANEL_WINDOW_PAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_WINDOW_PAGER, PanelWindowPagerPrivate))
enum  {
	PANEL_WINDOW_PAGER_DUMMY_PROPERTY
};
void panel_window_pager_reset_show_desktop (PanelWindowPager* self);
PanelWindowPager* panel_window_pager_new (void);
PanelWindowPager* panel_window_pager_construct (GType object_type);
PanelAbstractWindow* panel_abstract_window_new (void);
PanelAbstractWindow* panel_abstract_window_construct (GType object_type);
static void __lambda44_ (PanelWindowPager* self);
static void ___lambda44__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static gboolean __lambda45_ (PanelWindowPager* self);
static void panel_window_pager_dismiss (PanelWindowPager* self);
static gboolean ___lambda45__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static gboolean __lambda46_ (PanelWindowPager* self);
void panel_screen_move_window (GtkWindow* window, GdkGravity gravity);
void utils_grab (GtkWindow* w);
static gboolean ___lambda46__gtk_widget_map_event (GtkWidget* _sender, GdkEvent* event, gpointer self);
static void panel_window_pager_real_get_preferred_width (GtkWidget* base, gint* min, gint* max);
void utils_ungrab (GtkWindow* w);
static void panel_window_pager_finalize (GObject* obj);
GType panel_window_pager_entry_get_type (void) G_GNUC_CONST;
#define PANEL_WINDOW_PAGER_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_WINDOW_PAGER_ENTRY, PanelWindowPagerEntryPrivate))
enum  {
	PANEL_WINDOW_PAGER_ENTRY_DUMMY_PROPERTY
};
void panel_window_pager_entry_hide_pager (PanelWindowPagerEntry* self);
PanelWindowPagerEntry* panel_window_pager_entry_new (void);
PanelWindowPagerEntry* panel_window_pager_entry_construct (GType object_type);
static gboolean __lambda47_ (PanelWindowPagerEntry* self, GdkEventButton* event);
static gboolean ___lambda47__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
void panel_window_pager_entry_reset_show_desktop (PanelWindowPagerEntry* self);
static void panel_window_pager_entry_real_get_preferred_height (GtkWidget* base, gint* min, gint* max);
static void panel_window_pager_entry_real_get_preferred_width (GtkWidget* base, gint* min, gint* max);
static gboolean panel_window_pager_entry_real_draw (GtkWidget* base, cairo_t* cr);
static void panel_window_pager_entry_finalize (GObject* obj);
GType panel_window_entry_get_type (void) G_GNUC_CONST;
#define PANEL_WINDOW_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_WINDOW_ENTRY, PanelWindowEntryPrivate))
enum  {
	PANEL_WINDOW_ENTRY_DUMMY_PROPERTY,
	PANEL_WINDOW_ENTRY_DRAW_INFO
};
gboolean panel_window_entry_is_on_current_workspace (PanelWindowEntry* self);
void panel_window_entry_sync_window_states (PanelWindowEntry* self);
PanelWindowEntry* panel_window_entry_new (WnckWindow* info);
PanelWindowEntry* panel_window_entry_construct (GType object_type, WnckWindow* info);
static void __lambda32_ (PanelWindowEntry* self, WnckWindowState mask, WnckWindowState new_state);
static void ___lambda32__wnck_window_state_changed (WnckWindow* _sender, WnckWindowState changed_mask, WnckWindowState new_state, gpointer self);
static void __lambda33_ (PanelWindowEntry* self);
static void ___lambda33__wnck_window_name_changed (WnckWindow* _sender, gpointer self);
static gboolean __lambda34_ (PanelWindowEntry* self, GdkEventCrossing* event);
static gboolean ___lambda34__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static gboolean __lambda35_ (PanelWindowEntry* self, GdkEventCrossing* event);
static gboolean ___lambda35__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static gboolean __lambda36_ (PanelWindowEntry* self, GdkEventButton* event);
void panel_window_entry_show_popup (PanelWindowEntry* self, GdkEventButton* event);
static gboolean ___lambda36__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda38_ (PanelWindowEntry* self);
GType panel_window_host_get_type (void) G_GNUC_CONST;
static gboolean ___lambda38__gtk_widget_drag_motion (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, guint time_, gpointer self);
static void panel_window_entry_update_icon (PanelWindowEntry* self);
static void panel_window_entry_real_get_preferred_height (GtkWidget* base, gint* min, gint* max);
static void panel_window_entry_real_get_preferred_width (GtkWidget* base, gint* min, gint* max);
static gboolean panel_window_entry_real_draw (GtkWidget* base, cairo_t* cr);
static void __lambda37_ (PanelWindowEntry* self);
static void ___lambda37__gtk_menu_shell_deactivate (GtkMenuShell* _sender, gpointer self);
static gboolean panel_window_entry_get_draw_info (PanelWindowEntry* self);
void panel_window_entry_set_draw_info (PanelWindowEntry* self, gboolean value);
static void panel_window_entry_finalize (GObject* obj);
static void _vala_panel_window_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_panel_window_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType panel_window_entry_descriptions_get_type (void) G_GNUC_CONST;
gpointer animated_property_ref (gpointer instance);
void animated_property_unref (gpointer instance);
GParamSpec* param_spec_animated_property (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_animated_property (GValue* value, gpointer v_object);
void value_take_animated_property (GValue* value, gpointer v_object);
gpointer value_get_animated_property (const GValue* value);
GType animated_property_get_type (void) G_GNUC_CONST;
#define PANEL_WINDOW_ENTRY_DESCRIPTIONS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, PanelWindowEntryDescriptionsPrivate))
enum  {
	PANEL_WINDOW_ENTRY_DESCRIPTIONS_DUMMY_PROPERTY,
	PANEL_WINDOW_ENTRY_DESCRIPTIONS_OFFSET
};
PanelWindowEntryDescriptions* panel_window_entry_descriptions_new (GeeHashMap* entry_map);
PanelWindowEntryDescriptions* panel_window_entry_descriptions_construct (GType object_type, GeeHashMap* entry_map);
AnimatedProperty* animated_property_new (GObject* o);
AnimatedProperty* animated_property_construct (GType object_type, GObject* o);
void animated_property_set_property (AnimatedProperty* self, const gchar* property_name);
static void __lambda39_ (PanelWindowEntryDescriptions* self);
static void ___lambda39__animated_property_frame (AnimatedProperty* _sender, gpointer self);
void panel_window_entry_descriptions_clear_entry (PanelWindowEntryDescriptions* self, PanelWindowEntry* e);
static void panel_window_entry_descriptions_real_get_preferred_height (GtkWidget* base, gint* min, gint* max);
static void panel_window_entry_descriptions_real_get_preferred_width (GtkWidget* base, gint* min, gint* max);
void panel_screen_get_primary_monitor_geometry (GdkRectangle* result);
static gint panel_window_entry_descriptions_drawInfo (PanelWindowEntryDescriptions* self, cairo_t* cr, GtkStyleContext* style, GtkStateFlags state, GdkPixbuf* icon, const gchar* text, gint start, gboolean backward);
gdouble panel_window_entry_descriptions_get_offset (PanelWindowEntryDescriptions* self);
static gboolean panel_window_entry_descriptions_real_draw (GtkWidget* base, cairo_t* cr);
void panel_window_entry_descriptions_activate (PanelWindowEntryDescriptions* self, PanelWindowEntry* e);
void panel_window_entry_descriptions_set_offset (PanelWindowEntryDescriptions* self, gdouble value);
void animated_property_set_final_value (AnimatedProperty* self, gdouble value);
void animated_property_start (AnimatedProperty* self);
void panel_window_entry_descriptions_deactivate (PanelWindowEntryDescriptions* self);
void panel_window_entry_descriptions_try_hide (PanelWindowEntryDescriptions* self);
static gboolean panel_window_entry_descriptions_real_hide (PanelWindowEntryDescriptions* self);
static gboolean _panel_window_entry_descriptions_real_hide_gsource_func (gpointer self);
void panel_window_entry_descriptions_update_position (PanelWindowEntryDescriptions* self, gint y);
static void panel_window_entry_descriptions_finalize (GObject* obj);
static void _vala_panel_window_entry_descriptions_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_panel_window_entry_descriptions_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType panel_tray_get_type (void) G_GNUC_CONST;
GType panel_calendar_get_type (void) G_GNUC_CONST;
#define PANEL_WINDOW_HOST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL_WINDOW_HOST, PanelWindowHostPrivate))
enum  {
	PANEL_WINDOW_HOST_DUMMY_PROPERTY
};
gboolean panel_window_host_no_windows_around (PanelWindowHost* self);
void panel_window_host_update (PanelWindowHost* self, gboolean emit_change_signals);
PanelWindowHost* panel_window_host_new (void);
PanelWindowHost* panel_window_host_construct (GType object_type);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
PanelTray* panel_tray_new (void);
PanelTray* panel_tray_construct (GType object_type);
GType panel_clock_get_type (void) G_GNUC_CONST;
PanelClock* panel_clock_new (void);
PanelClock* panel_clock_construct (GType object_type);
PanelCalendar* panel_calendar_new (void);
PanelCalendar* panel_calendar_construct (GType object_type);
void panel_calendar_update_position (PanelCalendar* self, gint y);
void panel_window_host_reposition (PanelWindowHost* self);
void panel_abstract_window_set_struts (PanelAbstractWindow* self);
static void __lambda48_ (PanelWindowHost* self);
static void ___lambda48__panel_abstract_window_screen_size_changed (PanelAbstractWindow* _sender, gpointer self);
static void __lambda49_ (PanelWindowHost* self, WnckWindow* w);
static void ___lambda50_ (PanelWindowHost* self);
static void ____lambda50__wnck_window_workspace_changed (WnckWindow* _sender, gpointer self);
static void ___lambda49__wnck_screen_window_opened (WnckScreen* _sender, WnckWindow* window, gpointer self);
static void __lambda51_ (PanelWindowHost* self, WnckWindow* w);
static void ___lambda51__wnck_screen_window_closed (WnckScreen* _sender, WnckWindow* window, gpointer self);
static void __lambda52_ (PanelWindowHost* self);
static void ___lambda52__wnck_screen_active_window_changed (WnckScreen* _sender, WnckWindow* previous_window, gpointer self);
static void __lambda53_ (PanelWindowHost* self);
static void ___lambda53__wnck_screen_viewports_changed (WnckScreen* _sender, gpointer self);
static void __lambda54_ (PanelWindowHost* self);
static void ___lambda54__wnck_screen_active_workspace_changed (WnckScreen* _sender, WnckWorkspace* previous_workspace, gpointer self);
static gboolean __lambda55_ (PanelWindowHost* self);
static gboolean ___lambda55__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static void __lambda56_ (Block2Data* _data2_);
static void ___lambda56__panel_window_host_all_windows_visible (PanelWindowHost* _sender, gpointer self);
static gboolean __lambda57_ (PanelWindowHost* self);
static gboolean ___lambda57__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
static gboolean __lambda58_ (PanelWindowHost* self);
static gboolean ___lambda58__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda59_ (PanelWindowHost* self);
static gboolean ___lambda59__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static void panel_window_host_real_get_preferred_width (GtkWidget* base, gint* min, gint* max);
static void panel_window_host_real_get_preferred_height (GtkWidget* base, gint* min, gint* max);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void ______lambda42_ (Block3Data* _data3_);
static void _______lambda42__panel_window_entry_entered (PanelWindowEntry* _sender, gpointer self);
static void ______lambda43_ (PanelWindowHost* self);
static void _______lambda43__panel_window_entry_left (PanelWindowEntry* _sender, gpointer self);
static void panel_window_host_finalize (GObject* obj);

static const GtkTargetEntry PANEL_WINDOW_ENTRY_target_list[1] = {{"STRING", (guint) 0, (guint) 0}};

void panel_window_pager_reset_show_desktop (PanelWindowPager* self) {
	GtkToggleButton* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->desktop;
	gtk_toggle_button_set_active (_tmp0_, FALSE);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda44_ (PanelWindowPager* self) {
	WnckScreen* screen = NULL;
	WnckScreen* _tmp0_ = NULL;
	WnckScreen* _tmp1_ = NULL;
	GtkToggleButton* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	_tmp0_ = wnck_screen_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	screen = _tmp1_;
	_tmp2_ = self->priv->desktop;
	_tmp3_ = gtk_toggle_button_get_active (_tmp2_);
	wnck_screen_toggle_showing_desktop (screen, _tmp3_);
	_g_object_unref0 (screen);
}


static void ___lambda44__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda44_ ((PanelWindowPager*) self);
}


static gboolean __lambda45_ (PanelWindowPager* self) {
	gboolean result = FALSE;
	panel_window_pager_dismiss (self);
	result = TRUE;
	return result;
}


static gboolean ___lambda45__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = __lambda45_ ((PanelWindowPager*) self);
	return result;
}


static gboolean __lambda46_ (PanelWindowPager* self) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_ = NULL;
	panel_screen_move_window ((GtkWindow*) self, GDK_GRAVITY_NORTH_EAST);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_window_raise (_tmp0_);
	utils_grab ((GtkWindow*) self);
	result = TRUE;
	return result;
}


static gboolean ___lambda46__gtk_widget_map_event (GtkWidget* _sender, GdkEvent* event, gpointer self) {
	gboolean result;
	result = __lambda46_ ((PanelWindowPager*) self);
	return result;
}


PanelWindowPager* panel_window_pager_construct (GType object_type) {
	PanelWindowPager * self = NULL;
	GtkVBox* box = NULL;
	GtkVBox* _tmp0_ = NULL;
	WnckPager* pager = NULL;
	WnckPager* _tmp1_ = NULL;
	GtkImage* icon = NULL;
	GtkImage* _tmp2_ = NULL;
	GtkToggleButton* _tmp3_ = NULL;
	GtkToggleButton* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	GtkToggleButton* _tmp6_ = NULL;
	GtkToggleButton* _tmp7_ = NULL;
	GtkToggleButton* _tmp8_ = NULL;
	GtkToggleButton* _tmp9_ = NULL;
	self = (PanelWindowPager*) panel_abstract_window_construct (object_type);
	gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_DOCK);
	_tmp0_ = (GtkVBox*) gtk_vbox_new (FALSE, 0);
	g_object_ref_sink (_tmp0_);
	box = _tmp0_;
	_tmp1_ = (WnckPager*) wnck_pager_new ();
	g_object_ref_sink (_tmp1_);
	pager = _tmp1_;
	wnck_pager_set_orientation (pager, GTK_ORIENTATION_VERTICAL);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) box);
	gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) pager, FALSE, FALSE, (guint) 0);
	gtk_widget_show ((GtkWidget*) pager);
	_tmp2_ = (GtkImage*) gtk_image_new_from_icon_name ("user-desktop", GTK_ICON_SIZE_LARGE_TOOLBAR);
	g_object_ref_sink (_tmp2_);
	icon = _tmp2_;
	_tmp3_ = (GtkToggleButton*) gtk_toggle_button_new ();
	g_object_ref_sink (_tmp3_);
	_g_object_unref0 (self->priv->desktop);
	self->priv->desktop = _tmp3_;
	_tmp4_ = self->priv->desktop;
	_tmp5_ = _ ("Click here to hide all windows and show desktop");
	gtk_widget_set_tooltip_text ((GtkWidget*) _tmp4_, _tmp5_);
	_tmp6_ = self->priv->desktop;
	gtk_container_add ((GtkContainer*) _tmp6_, (GtkWidget*) icon);
	_tmp7_ = self->priv->desktop;
	gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) _tmp7_, TRUE, TRUE, (guint) 0);
	_tmp8_ = self->priv->desktop;
	gtk_widget_show_all ((GtkWidget*) _tmp8_);
	gtk_widget_show ((GtkWidget*) box);
	gtk_widget_hide ((GtkWidget*) self);
	_tmp9_ = self->priv->desktop;
	g_signal_connect_object (_tmp9_, "toggled", (GCallback) ___lambda44__gtk_toggle_button_toggled, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "leave-notify-event", (GCallback) ___lambda45__gtk_widget_leave_notify_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "map-event", (GCallback) ___lambda46__gtk_widget_map_event, self, 0);
	_g_object_unref0 (icon);
	_g_object_unref0 (pager);
	_g_object_unref0 (box);
	return self;
}


PanelWindowPager* panel_window_pager_new (void) {
	return panel_window_pager_construct (TYPE_PANEL_WINDOW_PAGER);
}


static void panel_window_pager_real_get_preferred_width (GtkWidget* base, gint* min, gint* max) {
	PanelWindowPager * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	self = (PanelWindowPager*) base;
	_vala_max = 80;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static void panel_window_pager_dismiss (PanelWindowPager* self) {
	g_return_if_fail (self != NULL);
	gtk_widget_hide ((GtkWidget*) self);
	utils_ungrab ((GtkWindow*) self);
}


static void panel_window_pager_class_init (PanelWindowPagerClass * klass) {
	panel_window_pager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelWindowPagerPrivate));
	((GtkWidgetClass *) klass)->get_preferred_width = panel_window_pager_real_get_preferred_width;
	G_OBJECT_CLASS (klass)->finalize = panel_window_pager_finalize;
	g_signal_new ("hidden", TYPE_PANEL_WINDOW_PAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void panel_window_pager_instance_init (PanelWindowPager * self) {
	self->priv = PANEL_WINDOW_PAGER_GET_PRIVATE (self);
}


static void panel_window_pager_finalize (GObject* obj) {
	PanelWindowPager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_WINDOW_PAGER, PanelWindowPager);
	_g_object_unref0 (self->priv->desktop);
	G_OBJECT_CLASS (panel_window_pager_parent_class)->finalize (obj);
}


GType panel_window_pager_get_type (void) {
	static volatile gsize panel_window_pager_type_id__volatile = 0;
	if (g_once_init_enter (&panel_window_pager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelWindowPagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_window_pager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelWindowPager), 0, (GInstanceInitFunc) panel_window_pager_instance_init, NULL };
		GType panel_window_pager_type_id;
		panel_window_pager_type_id = g_type_register_static (TYPE_PANEL_ABSTRACT_WINDOW, "PanelWindowPager", &g_define_type_info, 0);
		g_once_init_leave (&panel_window_pager_type_id__volatile, panel_window_pager_type_id);
	}
	return panel_window_pager_type_id__volatile;
}


void panel_window_pager_entry_hide_pager (PanelWindowPagerEntry* self) {
	PanelWindowPager* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->pager;
	gtk_widget_hide ((GtkWidget*) _tmp0_);
}


static gboolean __lambda47_ (PanelWindowPagerEntry* self, GdkEventButton* event) {
	gboolean result = FALSE;
	PanelWindowPager* _tmp0_ = NULL;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->pager;
	gtk_widget_show_all ((GtkWidget*) _tmp0_);
	g_signal_emit_by_name (self, "pager-shown");
	result = FALSE;
	return result;
}


static gboolean ___lambda47__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda47_ ((PanelWindowPagerEntry*) self, event);
	return result;
}


PanelWindowPagerEntry* panel_window_pager_entry_construct (GType object_type) {
	PanelWindowPagerEntry * self = NULL;
	GtkIconTheme* icon_theme = NULL;
	GtkIconTheme* _tmp0_ = NULL;
	GtkIconTheme* _tmp1_ = NULL;
	PanelWindowPager* _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	self = (PanelWindowPagerEntry*) g_object_new (object_type, NULL);
	gtk_widget_add_events ((GtkWidget*) self, (gint) ((((GDK_STRUCTURE_MASK | GDK_BUTTON_PRESS_MASK) | GDK_BUTTON_RELEASE_MASK) | GDK_ENTER_NOTIFY_MASK) | GDK_LEAVE_NOTIFY_MASK));
	_tmp0_ = gtk_icon_theme_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	icon_theme = _tmp1_;
	{
		GdkPixbuf* _tmp2_ = NULL;
		GdkPixbuf* _tmp3_ = NULL;
		GdkPixbuf* _tmp4_ = NULL;
		_tmp3_ = gtk_icon_theme_load_icon (icon_theme, "user-desktop", 32, 0, &_inner_error_);
		_tmp2_ = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp4_ = _tmp2_;
		_tmp2_ = NULL;
		_g_object_unref0 (self->priv->icon);
		self->priv->icon = _tmp4_;
		_g_object_unref0 (_tmp2_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp5_ = NULL;
		GError* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = stderr;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		fprintf (_tmp5_, "Unable to load icon 'user-desktop': %s\n", _tmp7_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (icon_theme);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp8_ = panel_window_pager_new ();
	g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->priv->pager);
	self->priv->pager = _tmp8_;
	gtk_widget_show ((GtkWidget*) self);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) ___lambda47__gtk_widget_button_press_event, self, 0);
	_g_object_unref0 (icon_theme);
	return self;
}


PanelWindowPagerEntry* panel_window_pager_entry_new (void) {
	return panel_window_pager_entry_construct (TYPE_PANEL_WINDOW_PAGER_ENTRY);
}


void panel_window_pager_entry_reset_show_desktop (PanelWindowPagerEntry* self) {
	PanelWindowPager* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->pager;
	panel_window_pager_reset_show_desktop (_tmp0_);
}


static void panel_window_pager_entry_real_get_preferred_height (GtkWidget* base, gint* min, gint* max) {
	PanelWindowPagerEntry * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	self = (PanelWindowPagerEntry*) base;
	_vala_max = 10;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static void panel_window_pager_entry_real_get_preferred_width (GtkWidget* base, gint* min, gint* max) {
	PanelWindowPagerEntry * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	self = (PanelWindowPagerEntry*) base;
	_vala_min = 50;
	_vala_max = _vala_min;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static gboolean panel_window_pager_entry_real_draw (GtkWidget* base, cairo_t* cr) {
	PanelWindowPagerEntry * self;
	gboolean result = FALSE;
	GtkStyleContext* style = NULL;
	GtkStyleContext* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	gint w = 0;
	GdkWindow* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint h = 0;
	GdkWindow* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	GtkStyleContext* _tmp6_ = NULL;
	cairo_t* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	GdkPixbuf* _tmp10_ = NULL;
	cairo_t* _tmp21_ = NULL;
	self = (PanelWindowPagerEntry*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style = _tmp1_;
	_tmp2_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp3_ = gdk_window_get_width (_tmp2_);
	w = _tmp3_;
	_tmp4_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp5_ = gdk_window_get_height (_tmp4_);
	h = _tmp5_;
	_tmp6_ = style;
	_tmp7_ = cr;
	_tmp8_ = w;
	_tmp9_ = h;
	gtk_render_background (_tmp6_, _tmp7_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp8_, (gdouble) _tmp9_);
	_tmp10_ = self->priv->icon;
	if (_tmp10_ != NULL) {
		cairo_t* _tmp11_ = NULL;
		GdkPixbuf* _tmp12_ = NULL;
		gint _tmp13_ = 0;
		GdkPixbuf* _tmp14_ = NULL;
		gint _tmp15_ = 0;
		gint _tmp16_ = 0;
		gint _tmp17_ = 0;
		GdkPixbuf* _tmp18_ = NULL;
		gint _tmp19_ = 0;
		gint _tmp20_ = 0;
		_tmp11_ = cr;
		_tmp12_ = self->priv->icon;
		_tmp13_ = w;
		_tmp14_ = self->priv->icon;
		_tmp15_ = gdk_pixbuf_get_width (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = h;
		_tmp18_ = self->priv->icon;
		_tmp19_ = gdk_pixbuf_get_height (_tmp18_);
		_tmp20_ = _tmp19_;
		gdk_cairo_set_source_pixbuf (_tmp11_, _tmp12_, (gdouble) ((_tmp13_ - _tmp16_) / 2), (gdouble) ((_tmp17_ - _tmp20_) / 2));
	}
	_tmp21_ = cr;
	cairo_paint (_tmp21_);
	result = TRUE;
	_g_object_unref0 (style);
	return result;
}


static void panel_window_pager_entry_class_init (PanelWindowPagerEntryClass * klass) {
	panel_window_pager_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelWindowPagerEntryPrivate));
	((GtkWidgetClass *) klass)->get_preferred_height = panel_window_pager_entry_real_get_preferred_height;
	((GtkWidgetClass *) klass)->get_preferred_width = panel_window_pager_entry_real_get_preferred_width;
	((GtkWidgetClass *) klass)->draw = panel_window_pager_entry_real_draw;
	G_OBJECT_CLASS (klass)->finalize = panel_window_pager_entry_finalize;
	g_signal_new ("pager_shown", TYPE_PANEL_WINDOW_PAGER_ENTRY, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void panel_window_pager_entry_instance_init (PanelWindowPagerEntry * self) {
	self->priv = PANEL_WINDOW_PAGER_ENTRY_GET_PRIVATE (self);
	self->priv->icon = NULL;
}


static void panel_window_pager_entry_finalize (GObject* obj) {
	PanelWindowPagerEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_WINDOW_PAGER_ENTRY, PanelWindowPagerEntry);
	_g_object_unref0 (self->priv->pager);
	_g_object_unref0 (self->priv->icon);
	G_OBJECT_CLASS (panel_window_pager_entry_parent_class)->finalize (obj);
}


GType panel_window_pager_entry_get_type (void) {
	static volatile gsize panel_window_pager_entry_type_id__volatile = 0;
	if (g_once_init_enter (&panel_window_pager_entry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelWindowPagerEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_window_pager_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelWindowPagerEntry), 0, (GInstanceInitFunc) panel_window_pager_entry_instance_init, NULL };
		GType panel_window_pager_entry_type_id;
		panel_window_pager_entry_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "PanelWindowPagerEntry", &g_define_type_info, 0);
		g_once_init_leave (&panel_window_pager_entry_type_id__volatile, panel_window_pager_entry_type_id);
	}
	return panel_window_pager_entry_type_id__volatile;
}


gboolean panel_window_entry_is_on_current_workspace (PanelWindowEntry* self) {
	gboolean result = FALSE;
	WnckWindow* _tmp0_ = NULL;
	WnckWindow* _tmp1_ = NULL;
	WnckScreen* _tmp2_ = NULL;
	WnckWorkspace* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->window_info;
	_tmp1_ = self->window_info;
	_tmp2_ = wnck_window_get_screen (_tmp1_);
	_tmp3_ = wnck_screen_get_active_workspace (_tmp2_);
	_tmp4_ = wnck_window_is_on_workspace (_tmp0_, _tmp3_);
	result = _tmp4_;
	return result;
}


void panel_window_entry_sync_window_states (PanelWindowEntry* self) {
	WnckWindow* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->window_info;
	_tmp1_ = wnck_window_is_minimized (_tmp0_);
	if (_tmp1_) {
		self->priv->state = GTK_STATE_FLAG_INSENSITIVE;
	} else {
		WnckWindow* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = self->window_info;
		_tmp3_ = wnck_window_is_active (_tmp2_);
		if (_tmp3_) {
			self->priv->state = GTK_STATE_FLAG_ACTIVE;
		} else {
			WnckWindow* _tmp4_ = NULL;
			gboolean _tmp5_ = FALSE;
			_tmp4_ = self->window_info;
			_tmp5_ = wnck_window_needs_attention (_tmp4_);
			if (_tmp5_) {
				self->priv->state = GTK_STATE_FLAG_SELECTED;
			} else {
				self->priv->state = GTK_STATE_FLAG_NORMAL;
			}
		}
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static void __lambda32_ (PanelWindowEntry* self, WnckWindowState mask, WnckWindowState new_state) {
	WnckWindowState _tmp0_ = 0;
	WnckWindowState _tmp1_ = 0;
	_tmp0_ = new_state;
	_tmp1_ = self->priv->last_state;
	if (_tmp0_ == _tmp1_) {
		return;
	}
	panel_window_entry_sync_window_states (self);
}


static void ___lambda32__wnck_window_state_changed (WnckWindow* _sender, WnckWindowState changed_mask, WnckWindowState new_state, gpointer self) {
	__lambda32_ ((PanelWindowEntry*) self, changed_mask, new_state);
}


static void __lambda33_ (PanelWindowEntry* self) {
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static void ___lambda33__wnck_window_name_changed (WnckWindow* _sender, gpointer self) {
	__lambda33_ ((PanelWindowEntry*) self);
}


static gboolean __lambda34_ (PanelWindowEntry* self, GdkEventCrossing* event) {
	gboolean result = FALSE;
	g_return_val_if_fail (event != NULL, FALSE);
	panel_window_entry_sync_window_states (self);
	g_signal_emit_by_name (self, "left");
	result = FALSE;
	return result;
}


static gboolean ___lambda34__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = __lambda34_ ((PanelWindowEntry*) self, event);
	return result;
}


static gboolean __lambda35_ (PanelWindowEntry* self, GdkEventCrossing* event) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (event != NULL, FALSE);
	self->priv->state = GTK_STATE_FLAG_PRELIGHT;
	gtk_widget_queue_draw ((GtkWidget*) self);
	_tmp0_ = self->priv->oversize;
	if (_tmp0_) {
		WnckWindow* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		_tmp1_ = self->window_info;
		_tmp2_ = wnck_window_get_name (_tmp1_);
		gtk_widget_set_tooltip_text ((GtkWidget*) self, _tmp2_);
	} else {
		gtk_widget_set_tooltip_text ((GtkWidget*) self, "");
	}
	g_signal_emit_by_name (self, "entered");
	result = FALSE;
	return result;
}


static gboolean ___lambda35__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = __lambda35_ ((PanelWindowEntry*) self, event);
	return result;
}


static gboolean __lambda36_ (PanelWindowEntry* self, GdkEventButton* event) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GdkEventButton _tmp1_ = {0};
	guint _tmp2_ = 0U;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp1_ = *event;
	_tmp2_ = _tmp1_.button;
	if (_tmp2_ == ((guint) 3)) {
		GdkEventButton _tmp3_ = {0};
		GdkEventType _tmp4_ = 0;
		_tmp3_ = *event;
		_tmp4_ = _tmp3_.type;
		_tmp0_ = _tmp4_ == GDK_BUTTON_PRESS;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GdkEventButton _tmp5_ = {0};
		_tmp5_ = *event;
		panel_window_entry_show_popup (self, &_tmp5_);
	} else {
		WnckWindow* _tmp6_ = NULL;
		gboolean _tmp7_ = FALSE;
		_tmp6_ = self->window_info;
		_tmp7_ = wnck_window_is_active (_tmp6_);
		if (_tmp7_) {
			WnckWindow* _tmp8_ = NULL;
			_tmp8_ = self->window_info;
			wnck_window_minimize (_tmp8_);
		} else {
			WnckWindow* _tmp9_ = NULL;
			guint32 _tmp10_ = 0U;
			_tmp9_ = self->window_info;
			_tmp10_ = gtk_get_current_event_time ();
			wnck_window_activate (_tmp9_, _tmp10_);
		}
		panel_window_entry_sync_window_states (self);
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda36__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda36_ ((PanelWindowEntry*) self, event);
	return result;
}


static gboolean __lambda38_ (PanelWindowEntry* self) {
	gboolean result = FALSE;
	GtkWidget* w = NULL;
	GtkWidget* _tmp0_ = NULL;
	GtkWidget* _tmp1_ = NULL;
	GtkWidget* _tmp2_ = NULL;
	WnckWindow* _tmp4_ = NULL;
	guint32 _tmp5_ = 0U;
	_tmp0_ = gtk_widget_get_toplevel ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	w = _tmp1_;
	_tmp2_ = w;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, TYPE_PANEL_WINDOW_HOST)) {
		GtkWidget* _tmp3_ = NULL;
		_tmp3_ = w;
		gtk_widget_activate ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp3_, TYPE_PANEL_WINDOW_HOST, PanelWindowHost));
	}
	_tmp4_ = self->window_info;
	_tmp5_ = gtk_get_current_event_time ();
	wnck_window_activate (_tmp4_, _tmp5_);
	panel_window_entry_sync_window_states (self);
	result = FALSE;
	_g_object_unref0 (w);
	return result;
}


static gboolean ___lambda38__gtk_widget_drag_motion (GtkWidget* _sender, GdkDragContext* context, gint x, gint y, guint time_, gpointer self) {
	gboolean result;
	result = __lambda38_ ((PanelWindowEntry*) self);
	return result;
}


PanelWindowEntry* panel_window_entry_construct (GType object_type, WnckWindow* info) {
	PanelWindowEntry * self = NULL;
	PangoContext* _tmp0_ = NULL;
	PangoLayout* _tmp1_ = NULL;
	WnckWindow* _tmp2_ = NULL;
	WnckWindow* _tmp3_ = NULL;
	WnckWindowState _tmp4_ = 0;
	WnckWindow* _tmp5_ = NULL;
	WnckWindow* _tmp6_ = NULL;
	g_return_val_if_fail (info != NULL, NULL);
	self = (PanelWindowEntry*) g_object_new (object_type, NULL);
	_tmp0_ = gtk_widget_get_pango_context ((GtkWidget*) self);
	_tmp1_ = pango_layout_new (_tmp0_);
	_g_object_unref0 (self->priv->pango);
	self->priv->pango = _tmp1_;
	gtk_widget_add_events ((GtkWidget*) self, (gint) ((((GDK_STRUCTURE_MASK | GDK_BUTTON_PRESS_MASK) | GDK_BUTTON_RELEASE_MASK) | GDK_ENTER_NOTIFY_MASK) | GDK_LEAVE_NOTIFY_MASK));
	_tmp2_ = info;
	self->window_info = _tmp2_;
	_tmp3_ = info;
	_tmp4_ = wnck_window_get_state (_tmp3_);
	self->priv->last_state = _tmp4_;
	panel_window_entry_sync_window_states (self);
	gtk_drag_dest_set ((GtkWidget*) self, GTK_DEST_DEFAULT_MOTION, PANEL_WINDOW_ENTRY_target_list, G_N_ELEMENTS (PANEL_WINDOW_ENTRY_target_list), GDK_ACTION_COPY);
	_tmp5_ = self->window_info;
	g_signal_connect_object (_tmp5_, "state-changed", (GCallback) ___lambda32__wnck_window_state_changed, self, 0);
	_tmp6_ = self->window_info;
	g_signal_connect_object (_tmp6_, "name-changed", (GCallback) ___lambda33__wnck_window_name_changed, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "leave-notify-event", (GCallback) ___lambda34__gtk_widget_leave_notify_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "enter-notify-event", (GCallback) ___lambda35__gtk_widget_enter_notify_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) ___lambda36__gtk_widget_button_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "drag-motion", (GCallback) ___lambda38__gtk_widget_drag_motion, self, 0);
	return self;
}


PanelWindowEntry* panel_window_entry_new (WnckWindow* info) {
	return panel_window_entry_construct (TYPE_PANEL_WINDOW_ENTRY, info);
}


static void panel_window_entry_update_icon (PanelWindowEntry* self) {
	WnckWindow* _tmp0_ = NULL;
	GdkPixbuf* _tmp1_ = NULL;
	GdkPixbuf* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->window_info;
	_tmp1_ = wnck_window_get_mini_icon (_tmp0_);
	self->priv->icon = _tmp1_;
	_tmp2_ = self->priv->icon;
	if (_tmp2_ == NULL) {
		WnckWindow* _tmp3_ = NULL;
		GdkPixbuf* _tmp4_ = NULL;
		_tmp3_ = self->window_info;
		_tmp4_ = wnck_window_get_icon (_tmp3_);
		self->priv->icon = _tmp4_;
	}
}


static void panel_window_entry_real_get_preferred_height (GtkWidget* base, gint* min, gint* max) {
	PanelWindowEntry * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	GdkPixbuf* _tmp0_ = NULL;
	self = (PanelWindowEntry*) base;
	panel_window_entry_update_icon (self);
	_tmp0_ = self->priv->icon;
	if (_tmp0_ != NULL) {
		GdkPixbuf* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		_tmp1_ = self->priv->icon;
		_tmp2_ = gdk_pixbuf_get_width (_tmp1_);
		_tmp3_ = self->priv->Margin;
		_vala_max = _tmp2_ + (_tmp3_ * 2);
		_tmp4_ = _vala_max;
		_vala_min = _tmp4_;
	} else {
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp5_ = self->priv->Margin;
		_vala_max = _tmp5_;
		_tmp6_ = _vala_max;
		_vala_min = _tmp6_;
	}
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static void panel_window_entry_real_get_preferred_width (GtkWidget* base, gint* min, gint* max) {
	PanelWindowEntry * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	self = (PanelWindowEntry*) base;
	gtk_widget_get_preferred_height ((GtkWidget*) self, &_tmp0_, &_tmp1_);
	_vala_min = _tmp0_;
	_vala_max = _tmp1_;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static gboolean panel_window_entry_real_draw (GtkWidget* base, cairo_t* cr) {
	PanelWindowEntry * self;
	gboolean result = FALSE;
	GtkStyleContext* style = NULL;
	GtkStyleContext* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStyleContext* _tmp2_ = NULL;
	GtkStateFlags _tmp3_ = 0;
	GtkStyleContext* _tmp4_ = NULL;
	cairo_t* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	GdkPixbuf* _tmp8_ = NULL;
	cairo_t* _tmp13_ = NULL;
	self = (PanelWindowEntry*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style = _tmp1_;
	_tmp2_ = style;
	_tmp3_ = self->priv->state;
	gtk_style_context_set_state (_tmp2_, _tmp3_);
	_tmp4_ = style;
	_tmp5_ = cr;
	_tmp6_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
	_tmp7_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	gtk_render_background (_tmp4_, _tmp5_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp6_, (gdouble) _tmp7_);
	panel_window_entry_update_icon (self);
	_tmp8_ = self->priv->icon;
	if (_tmp8_ != NULL) {
		cairo_t* _tmp9_ = NULL;
		GdkPixbuf* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		_tmp9_ = cr;
		_tmp10_ = self->priv->icon;
		_tmp11_ = self->priv->Margin;
		_tmp12_ = self->priv->Margin;
		gdk_cairo_set_source_pixbuf (_tmp9_, _tmp10_, (gdouble) _tmp11_, (gdouble) _tmp12_);
	}
	_tmp13_ = cr;
	cairo_paint (_tmp13_);
	result = TRUE;
	_g_object_unref0 (style);
	return result;
}


static void __lambda37_ (PanelWindowEntry* self) {
	self->priv->popup_shown = FALSE;
}


static void ___lambda37__gtk_menu_shell_deactivate (GtkMenuShell* _sender, gpointer self) {
	__lambda37_ ((PanelWindowEntry*) self);
}


void panel_window_entry_show_popup (PanelWindowEntry* self, GdkEventButton* event) {
	WnckActionMenu* menu = NULL;
	WnckWindow* _tmp0_ = NULL;
	WnckActionMenu* _tmp1_ = NULL;
	guint button = 0U;
	GdkEventButton _tmp2_ = {0};
	guint _tmp3_ = 0U;
	guint32 event_time = 0U;
	GdkEventButton _tmp4_ = {0};
	guint32 _tmp5_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	_tmp0_ = self->window_info;
	_tmp1_ = (WnckActionMenu*) wnck_action_menu_new (_tmp0_);
	g_object_ref_sink (_tmp1_);
	menu = _tmp1_;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.button;
	button = _tmp3_;
	_tmp4_ = *event;
	_tmp5_ = _tmp4_.time;
	event_time = _tmp5_;
	g_signal_connect_object ((GtkMenuShell*) menu, "deactivate", (GCallback) ___lambda37__gtk_menu_shell_deactivate, self, 0);
	gtk_menu_attach_to_widget ((GtkMenu*) menu, (GtkWidget*) self, NULL);
	self->priv->popup_shown = TRUE;
	gtk_menu_popup ((GtkMenu*) menu, NULL, NULL, NULL, NULL, button, event_time);
	_g_object_unref0 (menu);
}


static gboolean panel_window_entry_get_draw_info (PanelWindowEntry* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_draw_info;
	result = _tmp0_;
	return result;
}


void panel_window_entry_set_draw_info (PanelWindowEntry* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_draw_info = _tmp0_;
	g_object_notify ((GObject *) self, "draw-info");
}


static void panel_window_entry_class_init (PanelWindowEntryClass * klass) {
	panel_window_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelWindowEntryPrivate));
	((GtkWidgetClass *) klass)->get_preferred_height = panel_window_entry_real_get_preferred_height;
	((GtkWidgetClass *) klass)->get_preferred_width = panel_window_entry_real_get_preferred_width;
	((GtkWidgetClass *) klass)->draw = panel_window_entry_real_draw;
	G_OBJECT_CLASS (klass)->get_property = _vala_panel_window_entry_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_panel_window_entry_set_property;
	G_OBJECT_CLASS (klass)->finalize = panel_window_entry_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANEL_WINDOW_ENTRY_DRAW_INFO, g_param_spec_boolean ("draw-info", "draw-info", "draw-info", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE));
	g_signal_new ("entered", TYPE_PANEL_WINDOW_ENTRY, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("left", TYPE_PANEL_WINDOW_ENTRY, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void panel_window_entry_instance_init (PanelWindowEntry * self) {
	self->priv = PANEL_WINDOW_ENTRY_GET_PRIVATE (self);
	self->priv->icon = NULL;
	self->priv->popup_shown = FALSE;
	self->priv->Margin = 5;
	self->priv->oversize = FALSE;
	self->priv->iconWidth = 24;
	self->priv->_draw_info = FALSE;
}


static void panel_window_entry_finalize (GObject* obj) {
	PanelWindowEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_WINDOW_ENTRY, PanelWindowEntry);
	_g_object_unref0 (self->priv->pango);
	G_OBJECT_CLASS (panel_window_entry_parent_class)->finalize (obj);
}


GType panel_window_entry_get_type (void) {
	static volatile gsize panel_window_entry_type_id__volatile = 0;
	if (g_once_init_enter (&panel_window_entry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelWindowEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_window_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelWindowEntry), 0, (GInstanceInitFunc) panel_window_entry_instance_init, NULL };
		GType panel_window_entry_type_id;
		panel_window_entry_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "PanelWindowEntry", &g_define_type_info, 0);
		g_once_init_leave (&panel_window_entry_type_id__volatile, panel_window_entry_type_id);
	}
	return panel_window_entry_type_id__volatile;
}


static void _vala_panel_window_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	PanelWindowEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_PANEL_WINDOW_ENTRY, PanelWindowEntry);
	switch (property_id) {
		case PANEL_WINDOW_ENTRY_DRAW_INFO:
		g_value_set_boolean (value, panel_window_entry_get_draw_info (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_panel_window_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	PanelWindowEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_PANEL_WINDOW_ENTRY, PanelWindowEntry);
	switch (property_id) {
		case PANEL_WINDOW_ENTRY_DRAW_INFO:
		panel_window_entry_set_draw_info (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void __lambda39_ (PanelWindowEntryDescriptions* self) {
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static void ___lambda39__animated_property_frame (AnimatedProperty* _sender, gpointer self) {
	__lambda39_ ((PanelWindowEntryDescriptions*) self);
}


PanelWindowEntryDescriptions* panel_window_entry_descriptions_construct (GType object_type, GeeHashMap* entry_map) {
	PanelWindowEntryDescriptions * self = NULL;
	PangoContext* _tmp0_ = NULL;
	PangoLayout* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	GeeHashMap* _tmp3_ = NULL;
	GeeHashMap* _tmp4_ = NULL;
	AnimatedProperty* _tmp5_ = NULL;
	AnimatedProperty* _tmp6_ = NULL;
	AnimatedProperty* _tmp7_ = NULL;
	g_return_val_if_fail (entry_map != NULL, NULL);
	self = (PanelWindowEntryDescriptions*) panel_abstract_window_construct (object_type);
	_tmp0_ = gtk_widget_get_pango_context ((GtkWidget*) self);
	_tmp1_ = pango_layout_new (_tmp0_);
	_g_object_unref0 (self->priv->pango);
	self->priv->pango = _tmp1_;
	_tmp2_ = gee_array_list_new (TYPE_PANEL_WINDOW_ENTRY, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->priv->stack);
	self->priv->stack = _tmp2_;
	_tmp3_ = gee_hash_map_new (TYPE_PANEL_WINDOW_ENTRY, (GBoxedCopyFunc) g_object_ref, g_object_unref, G_TYPE_INT, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->position_map);
	self->priv->position_map = _tmp3_;
	_tmp4_ = entry_map;
	self->priv->entry_map = _tmp4_;
	gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_DOCK);
	gtk_widget_set_app_paintable ((GtkWidget*) self, TRUE);
	self->priv->margin = 0;
	gtk_widget_hide ((GtkWidget*) self);
	panel_screen_move_window ((GtkWindow*) self, GDK_GRAVITY_NORTH_WEST);
	_tmp5_ = animated_property_new ((GObject*) self);
	_animated_property_unref0 (self->priv->anim);
	self->priv->anim = _tmp5_;
	_tmp6_ = self->priv->anim;
	animated_property_set_property (_tmp6_, "offset");
	_tmp7_ = self->priv->anim;
	g_signal_connect_object (_tmp7_, "frame", (GCallback) ___lambda39__animated_property_frame, self, 0);
	return self;
}


PanelWindowEntryDescriptions* panel_window_entry_descriptions_new (GeeHashMap* entry_map) {
	return panel_window_entry_descriptions_construct (TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, entry_map);
}


void panel_window_entry_descriptions_clear_entry (PanelWindowEntryDescriptions* self, PanelWindowEntry* e) {
	GeeHashMap* _tmp0_ = NULL;
	PanelWindowEntry* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
	_tmp0_ = self->priv->position_map;
	_tmp1_ = e;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp0_, _tmp1_, NULL);
}


static void panel_window_entry_descriptions_real_get_preferred_height (GtkWidget* base, gint* min, gint* max) {
	PanelWindowEntryDescriptions * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	self = (PanelWindowEntryDescriptions*) base;
	_vala_max = 34;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static void panel_window_entry_descriptions_real_get_preferred_width (GtkWidget* base, gint* min, gint* max) {
	PanelWindowEntryDescriptions * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	GdkRectangle _tmp0_ = {0};
	gint _tmp1_ = 0;
	self = (PanelWindowEntryDescriptions*) base;
	panel_screen_get_primary_monitor_geometry (&_tmp0_);
	_tmp1_ = _tmp0_.width;
	_vala_max = _tmp1_;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static gint panel_window_entry_descriptions_drawInfo (PanelWindowEntryDescriptions* self, cairo_t* cr, GtkStyleContext* style, GtkStateFlags state, GdkPixbuf* icon, const gchar* text, gint start, gboolean backward) {
	gint result = 0;
	GtkTextDirection dir = 0;
	GtkTextDirection _tmp0_ = 0;
	gint icon_x = 0;
	gint icon_y = 0;
	gint icon_width = 0;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStateFlags _tmp2_ = 0;
	GdkPixbuf* _tmp3_ = NULL;
	PangoLayout* _tmp6_ = NULL;
	GtkStyleContext* _tmp7_ = NULL;
	GtkStateFlags _tmp8_ = 0;
	PangoFontDescription* _tmp9_ = NULL;
	PangoLayout* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gint h = 0;
	GdkWindow* _tmp14_ = NULL;
	gint _tmp15_ = 0;
	gint icon_margin = 0;
	gint text_x = 0;
	gint text_y = 0;
	gint text_w = 0;
	gint text_h = 0;
	PangoLayout* _tmp16_ = NULL;
	gint _tmp17_ = 0;
	gint _tmp18_ = 0;
	gint _tmp19_ = 0;
	gint _tmp20_ = 0;
	gboolean _tmp21_ = FALSE;
	gint occupied = 0;
	gint _tmp37_ = 0;
	gint _tmp38_ = 0;
	gint _tmp39_ = 0;
	GtkStyleContext* _tmp40_ = NULL;
	cairo_t* _tmp41_ = NULL;
	gint _tmp42_ = 0;
	gdouble _tmp43_ = 0.0;
	gint _tmp44_ = 0;
	gint _tmp45_ = 0;
	gint _tmp46_ = 0;
	GdkPixbuf* _tmp47_ = NULL;
	GtkStyleContext* _tmp52_ = NULL;
	cairo_t* _tmp53_ = NULL;
	gint _tmp54_ = 0;
	gdouble _tmp55_ = 0.0;
	gint _tmp56_ = 0;
	PangoLayout* _tmp57_ = NULL;
	GtkStateFlags _tmp58_ = 0;
	gint new_start = 0;
	gint _tmp61_ = 0;
	gint _tmp62_ = 0;
	gboolean _tmp63_ = FALSE;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (cr != NULL, 0);
	g_return_val_if_fail (style != NULL, 0);
	g_return_val_if_fail (text != NULL, 0);
	_tmp0_ = gtk_widget_get_direction ((GtkWidget*) self);
	dir = _tmp0_;
	icon_x = 0;
	icon_y = 0;
	icon_width = 0;
	_tmp1_ = style;
	_tmp2_ = state;
	gtk_style_context_set_state (_tmp1_, _tmp2_);
	_tmp3_ = icon;
	if (_tmp3_ != NULL) {
		GdkPixbuf* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		_tmp4_ = icon;
		_tmp5_ = gdk_pixbuf_get_width (_tmp4_);
		icon_width = _tmp5_;
	}
	_tmp6_ = self->priv->pango;
	_tmp7_ = style;
	_tmp8_ = state;
	_tmp9_ = gtk_style_context_get_font (_tmp7_, _tmp8_);
	pango_layout_set_font_description (_tmp6_, _tmp9_);
	_tmp10_ = self->priv->pango;
	_tmp11_ = text;
	_tmp12_ = g_strdup_printf ("<big>%s</big>", _tmp11_);
	_tmp13_ = _tmp12_;
	pango_layout_set_markup (_tmp10_, _tmp13_, -1);
	_g_free0 (_tmp13_);
	_tmp14_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp15_ = gdk_window_get_height (_tmp14_);
	h = _tmp15_;
	icon_margin = 5;
	_tmp16_ = self->priv->pango;
	pango_layout_get_pixel_size (_tmp16_, &_tmp17_, &_tmp18_);
	text_w = _tmp17_;
	text_h = _tmp18_;
	_tmp19_ = h;
	_tmp20_ = text_h;
	text_y = (_tmp19_ / 2) - (_tmp20_ / 2);
	_tmp21_ = backward;
	if (_tmp21_) {
		gint _tmp22_ = 0;
		gint _tmp23_ = 0;
		gint _tmp24_ = 0;
		gint _tmp25_ = 0;
		GtkTextDirection _tmp26_ = 0;
		_tmp22_ = start;
		_tmp23_ = icon_margin;
		_tmp24_ = icon_width;
		_tmp25_ = text_w;
		icon_x = _tmp22_ - (((_tmp23_ * 2) + _tmp24_) + _tmp25_);
		_tmp26_ = dir;
		if (_tmp26_ == GTK_TEXT_DIR_LTR) {
			gint _tmp27_ = 0;
			gint _tmp28_ = 0;
			gint _tmp29_ = 0;
			_tmp27_ = start;
			_tmp28_ = icon_margin;
			_tmp29_ = text_w;
			text_x = _tmp27_ - (_tmp28_ + _tmp29_);
		} else {
			gint _tmp30_ = 0;
			_tmp30_ = start;
			text_x = _tmp30_;
		}
	} else {
		gint _tmp31_ = 0;
		GtkTextDirection _tmp32_ = 0;
		_tmp31_ = start;
		icon_x = _tmp31_;
		_tmp32_ = dir;
		if (_tmp32_ == GTK_TEXT_DIR_LTR) {
			gint _tmp33_ = 0;
			gint _tmp34_ = 0;
			gint _tmp35_ = 0;
			_tmp33_ = start;
			_tmp34_ = icon_width;
			_tmp35_ = icon_margin;
			text_x = (_tmp33_ + _tmp34_) + _tmp35_;
		} else {
			gint _tmp36_ = 0;
			_tmp36_ = start;
			text_x = _tmp36_;
		}
	}
	_tmp37_ = icon_margin;
	_tmp38_ = text_w;
	_tmp39_ = icon_width;
	occupied = ((_tmp37_ * 3) + _tmp38_) + _tmp39_;
	_tmp40_ = style;
	_tmp41_ = cr;
	_tmp42_ = icon_x;
	_tmp43_ = self->priv->_offset;
	_tmp44_ = icon_margin;
	_tmp45_ = occupied;
	_tmp46_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	gtk_render_background (_tmp40_, _tmp41_, (_tmp42_ + _tmp43_) - _tmp44_, (gdouble) 0, (gdouble) _tmp45_, (gdouble) _tmp46_);
	_tmp47_ = icon;
	if (_tmp47_ != NULL) {
		cairo_t* _tmp48_ = NULL;
		GdkPixbuf* _tmp49_ = NULL;
		gint _tmp50_ = 0;
		gdouble _tmp51_ = 0.0;
		_tmp48_ = cr;
		_tmp49_ = icon;
		_tmp50_ = icon_x;
		_tmp51_ = self->priv->_offset;
		gdk_cairo_set_source_pixbuf (_tmp48_, _tmp49_, _tmp50_ + _tmp51_, (gdouble) 0);
	}
	_tmp52_ = style;
	_tmp53_ = cr;
	_tmp54_ = text_x;
	_tmp55_ = self->priv->_offset;
	_tmp56_ = text_y;
	_tmp57_ = self->priv->pango;
	gtk_render_layout (_tmp52_, _tmp53_, _tmp54_ + _tmp55_, (gdouble) _tmp56_, _tmp57_);
	_tmp58_ = state;
	if (_tmp58_ == GTK_STATE_FLAG_NORMAL) {
		cairo_t* _tmp59_ = NULL;
		_tmp59_ = cr;
		cairo_paint_with_alpha (_tmp59_, 0.5);
	} else {
		cairo_t* _tmp60_ = NULL;
		_tmp60_ = cr;
		cairo_paint (_tmp60_);
	}
	_tmp61_ = occupied;
	_tmp62_ = start;
	new_start = _tmp61_ + _tmp62_;
	_tmp63_ = backward;
	if (_tmp63_) {
		gint _tmp64_ = 0;
		gint _tmp65_ = 0;
		_tmp64_ = start;
		_tmp65_ = new_start;
		result = _tmp64_ - _tmp65_;
		return result;
	} else {
		result = new_start;
		return result;
	}
}


static gboolean panel_window_entry_descriptions_real_draw (GtkWidget* base, cairo_t* cr) {
	PanelWindowEntryDescriptions * self;
	gboolean result = FALSE;
	GtkStyleContext* style = NULL;
	GtkStyleContext* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	GtkStateFlags state = 0;
	GtkStyleContext* _tmp3_ = NULL;
	GtkStateFlags _tmp4_ = 0;
	GtkStyleContext* _tmp5_ = NULL;
	cairo_t* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	cairo_t* _tmp9_ = NULL;
	PanelWindowEntry* _tmp10_ = NULL;
	self = (PanelWindowEntryDescriptions*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	style = _tmp1_;
	_tmp2_ = self->priv->stack;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp2_);
	state = GTK_STATE_FLAG_NORMAL;
	_tmp3_ = style;
	_tmp4_ = state;
	gtk_style_context_set_state (_tmp3_, _tmp4_);
	_tmp5_ = style;
	_tmp6_ = cr;
	_tmp7_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
	_tmp8_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	gtk_render_background (_tmp5_, _tmp6_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp7_, (gdouble) _tmp8_);
	_tmp9_ = cr;
	cairo_paint (_tmp9_);
	_tmp10_ = self->priv->active_entry;
	if (_tmp10_ != NULL) {
		gint start_x = 0;
		gboolean pushing = FALSE;
		gint backward_start = 0;
		gint _tmp51_ = 0;
		start_x = -1;
		pushing = TRUE;
		backward_start = -1;
		{
			GeeIterator* _e_it = NULL;
			GeeHashMap* _tmp11_ = NULL;
			GeeCollection* _tmp12_ = NULL;
			GeeCollection* _tmp13_ = NULL;
			GeeCollection* _tmp14_ = NULL;
			GeeIterator* _tmp15_ = NULL;
			GeeIterator* _tmp16_ = NULL;
			_tmp11_ = self->priv->entry_map;
			_tmp12_ = gee_abstract_map_get_values ((GeeMap*) _tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = _tmp13_;
			_tmp15_ = gee_iterable_iterator ((GeeIterable*) _tmp14_);
			_tmp16_ = _tmp15_;
			_g_object_unref0 (_tmp14_);
			_e_it = _tmp16_;
			while (TRUE) {
				GeeIterator* _tmp17_ = NULL;
				gboolean _tmp18_ = FALSE;
				PanelWindowEntry* e = NULL;
				GeeIterator* _tmp19_ = NULL;
				gpointer _tmp20_ = NULL;
				PanelWindowEntry* _tmp21_ = NULL;
				gboolean _tmp22_ = FALSE;
				PanelWindowEntry* _tmp23_ = NULL;
				PanelWindowEntry* _tmp24_ = NULL;
				gboolean _tmp34_ = FALSE;
				_tmp17_ = _e_it;
				_tmp18_ = gee_iterator_next (_tmp17_);
				if (!_tmp18_) {
					break;
				}
				_tmp19_ = _e_it;
				_tmp20_ = gee_iterator_get (_tmp19_);
				e = (PanelWindowEntry*) _tmp20_;
				_tmp21_ = e;
				_tmp22_ = panel_window_entry_is_on_current_workspace (_tmp21_);
				if (_tmp22_ == FALSE) {
					continue;
				}
				_tmp23_ = e;
				_tmp24_ = self->priv->active_entry;
				if (_tmp23_ == _tmp24_) {
					gint x = 0;
					gint y = 0;
					PanelWindowEntry* _tmp25_ = NULL;
					GdkWindow* _tmp26_ = NULL;
					gint _tmp27_ = 0;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					gint _tmp30_ = 0;
					state = GTK_STATE_FLAG_PRELIGHT;
					_tmp25_ = e;
					_tmp26_ = gtk_widget_get_window ((GtkWidget*) _tmp25_);
					gdk_window_get_position (_tmp26_, &_tmp27_, &_tmp28_);
					x = _tmp27_;
					y = _tmp28_;
					_tmp29_ = x;
					start_x = _tmp29_;
					pushing = FALSE;
					_tmp30_ = x;
					backward_start = _tmp30_;
				} else {
					gboolean _tmp31_ = FALSE;
					state = GTK_STATE_FLAG_NORMAL;
					_tmp31_ = pushing;
					if (_tmp31_) {
						GeeArrayList* _tmp32_ = NULL;
						PanelWindowEntry* _tmp33_ = NULL;
						_tmp32_ = self->priv->stack;
						_tmp33_ = e;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp32_, _tmp33_);
					}
				}
				_tmp34_ = pushing;
				if (_tmp34_ == FALSE) {
					GdkPixbuf* icon = NULL;
					PanelWindowEntry* _tmp35_ = NULL;
					WnckWindow* _tmp36_ = NULL;
					GdkPixbuf* _tmp37_ = NULL;
					GdkPixbuf* _tmp38_ = NULL;
					GeeHashMap* _tmp39_ = NULL;
					PanelWindowEntry* _tmp40_ = NULL;
					gint _tmp41_ = 0;
					cairo_t* _tmp42_ = NULL;
					GtkStyleContext* _tmp43_ = NULL;
					GtkStateFlags _tmp44_ = 0;
					GdkPixbuf* _tmp45_ = NULL;
					PanelWindowEntry* _tmp46_ = NULL;
					WnckWindow* _tmp47_ = NULL;
					const gchar* _tmp48_ = NULL;
					gint _tmp49_ = 0;
					gint _tmp50_ = 0;
					_tmp35_ = e;
					_tmp36_ = _tmp35_->window_info;
					_tmp37_ = wnck_window_get_icon (_tmp36_);
					_tmp38_ = _g_object_ref0 (_tmp37_);
					icon = _tmp38_;
					_tmp39_ = self->priv->position_map;
					_tmp40_ = e;
					_tmp41_ = start_x;
					gee_abstract_map_set ((GeeAbstractMap*) _tmp39_, _tmp40_, (gpointer) ((gintptr) _tmp41_));
					_tmp42_ = cr;
					_tmp43_ = style;
					_tmp44_ = state;
					_tmp45_ = icon;
					_tmp46_ = e;
					_tmp47_ = _tmp46_->window_info;
					_tmp48_ = wnck_window_get_name (_tmp47_);
					_tmp49_ = start_x;
					_tmp50_ = panel_window_entry_descriptions_drawInfo (self, _tmp42_, _tmp43_, _tmp44_, _tmp45_, _tmp48_, _tmp49_, FALSE);
					start_x = _tmp50_;
					_g_object_unref0 (icon);
				}
			}
			_g_object_unref0 (_e_it);
		}
		_tmp51_ = backward_start;
		start_x = _tmp51_;
		state = GTK_STATE_FLAG_NORMAL;
		while (TRUE) {
			GeeArrayList* _tmp52_ = NULL;
			gint _tmp53_ = 0;
			gint _tmp54_ = 0;
			PanelWindowEntry* e = NULL;
			GeeArrayList* _tmp55_ = NULL;
			GeeArrayList* _tmp56_ = NULL;
			gint _tmp57_ = 0;
			gint _tmp58_ = 0;
			gpointer _tmp59_ = NULL;
			PanelWindowEntry* _tmp60_ = NULL;
			GdkPixbuf* icon = NULL;
			PanelWindowEntry* _tmp61_ = NULL;
			WnckWindow* _tmp62_ = NULL;
			GdkPixbuf* _tmp63_ = NULL;
			GdkPixbuf* _tmp64_ = NULL;
			cairo_t* _tmp65_ = NULL;
			GtkStyleContext* _tmp66_ = NULL;
			GtkStateFlags _tmp67_ = 0;
			GdkPixbuf* _tmp68_ = NULL;
			PanelWindowEntry* _tmp69_ = NULL;
			WnckWindow* _tmp70_ = NULL;
			const gchar* _tmp71_ = NULL;
			gint _tmp72_ = 0;
			gint _tmp73_ = 0;
			GeeHashMap* _tmp74_ = NULL;
			PanelWindowEntry* _tmp75_ = NULL;
			gint _tmp76_ = 0;
			_tmp52_ = self->priv->stack;
			_tmp53_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp52_);
			_tmp54_ = _tmp53_;
			if (!(_tmp54_ > 0)) {
				break;
			}
			_tmp55_ = self->priv->stack;
			_tmp56_ = self->priv->stack;
			_tmp57_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp56_);
			_tmp58_ = _tmp57_;
			_tmp59_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp55_, _tmp58_ - 1);
			e = (PanelWindowEntry*) _tmp59_;
			_tmp60_ = e;
			if (_tmp60_ == NULL) {
				_g_object_unref0 (e);
				break;
			}
			_tmp61_ = e;
			_tmp62_ = _tmp61_->window_info;
			_tmp63_ = wnck_window_get_icon (_tmp62_);
			_tmp64_ = _g_object_ref0 (_tmp63_);
			icon = _tmp64_;
			_tmp65_ = cr;
			_tmp66_ = style;
			_tmp67_ = state;
			_tmp68_ = icon;
			_tmp69_ = e;
			_tmp70_ = _tmp69_->window_info;
			_tmp71_ = wnck_window_get_name (_tmp70_);
			_tmp72_ = start_x;
			_tmp73_ = panel_window_entry_descriptions_drawInfo (self, _tmp65_, _tmp66_, _tmp67_, _tmp68_, _tmp71_, _tmp72_, TRUE);
			start_x = _tmp73_;
			_tmp74_ = self->priv->position_map;
			_tmp75_ = e;
			_tmp76_ = start_x;
			gee_abstract_map_set ((GeeAbstractMap*) _tmp74_, _tmp75_, (gpointer) ((gintptr) _tmp76_));
			_g_object_unref0 (icon);
			_g_object_unref0 (e);
		}
	}
	result = TRUE;
	_g_object_unref0 (style);
	return result;
}


void panel_window_entry_descriptions_activate (PanelWindowEntryDescriptions* self, PanelWindowEntry* e) {
	PanelWindowEntry* _tmp0_ = NULL;
	PanelWindowEntry* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gint start = 0;
	GeeHashMap* _tmp3_ = NULL;
	PanelWindowEntry* _tmp4_ = NULL;
	gpointer _tmp5_ = NULL;
	gint end = 0;
	PanelWindowEntry* _tmp6_ = NULL;
	AnimatedProperty* _tmp12_ = NULL;
	AnimatedProperty* _tmp13_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
	self->priv->hiding = FALSE;
	_tmp0_ = self->priv->active_entry;
	self->priv->old_entry = _tmp0_;
	_tmp1_ = e;
	self->priv->active_entry = _tmp1_;
	_tmp2_ = gtk_widget_get_visible ((GtkWidget*) self);
	if (_tmp2_ == FALSE) {
		gtk_widget_show_all ((GtkWidget*) self);
	} else {
		gtk_widget_queue_draw ((GtkWidget*) self);
	}
	_tmp3_ = self->priv->position_map;
	_tmp4_ = e;
	_tmp5_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp3_, _tmp4_);
	start = (gint) ((gintptr) _tmp5_);
	end = 0;
	panel_window_entry_descriptions_set_offset (self, (gdouble) 0);
	_tmp6_ = self->priv->old_entry;
	if (_tmp6_ != NULL) {
		GeeHashMap* _tmp7_ = NULL;
		PanelWindowEntry* _tmp8_ = NULL;
		gpointer _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		_tmp7_ = self->priv->position_map;
		_tmp8_ = self->priv->old_entry;
		_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
		end = (gint) ((gintptr) _tmp9_);
		_tmp10_ = start;
		_tmp11_ = end;
		panel_window_entry_descriptions_set_offset (self, (gdouble) (_tmp10_ - _tmp11_));
	}
	_tmp12_ = self->priv->anim;
	animated_property_set_final_value (_tmp12_, (gdouble) 0);
	_tmp13_ = self->priv->anim;
	animated_property_start (_tmp13_);
}


void panel_window_entry_descriptions_deactivate (PanelWindowEntryDescriptions* self) {
	g_return_if_fail (self != NULL);
	panel_window_entry_descriptions_try_hide (self);
}


static gboolean _panel_window_entry_descriptions_real_hide_gsource_func (gpointer self) {
	gboolean result;
	result = panel_window_entry_descriptions_real_hide ((PanelWindowEntryDescriptions*) self);
	return result;
}


void panel_window_entry_descriptions_try_hide (PanelWindowEntryDescriptions* self) {
	g_return_if_fail (self != NULL);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 250, _panel_window_entry_descriptions_real_hide_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->hiding = TRUE;
}


static gboolean panel_window_entry_descriptions_real_hide (PanelWindowEntryDescriptions* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->hiding;
	if (_tmp0_ == TRUE) {
		gtk_widget_hide ((GtkWidget*) self);
	}
	result = FALSE;
	return result;
}


void panel_window_entry_descriptions_update_position (PanelWindowEntryDescriptions* self, gint y) {
	GdkRectangle g = {0};
	GdkRectangle _tmp0_ = {0};
	GdkRectangle _tmp1_ = {0};
	gint _tmp2_ = 0;
	GdkRectangle _tmp3_ = {0};
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	g_return_if_fail (self != NULL);
	gtk_widget_queue_resize ((GtkWidget*) self);
	panel_screen_get_primary_monitor_geometry (&_tmp0_);
	g = _tmp0_;
	_tmp1_ = g;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = g;
	_tmp4_ = _tmp3_.y;
	_tmp5_ = y;
	gtk_window_move ((GtkWindow*) self, _tmp2_, _tmp4_ + _tmp5_);
}


gdouble panel_window_entry_descriptions_get_offset (PanelWindowEntryDescriptions* self) {
	gdouble result;
	gdouble _tmp0_ = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = self->priv->_offset;
	result = _tmp0_;
	return result;
}


void panel_window_entry_descriptions_set_offset (PanelWindowEntryDescriptions* self, gdouble value) {
	gdouble _tmp0_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_offset = _tmp0_;
	g_object_notify ((GObject *) self, "offset");
}


static void panel_window_entry_descriptions_class_init (PanelWindowEntryDescriptionsClass * klass) {
	panel_window_entry_descriptions_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelWindowEntryDescriptionsPrivate));
	((GtkWidgetClass *) klass)->get_preferred_height = panel_window_entry_descriptions_real_get_preferred_height;
	((GtkWidgetClass *) klass)->get_preferred_width = panel_window_entry_descriptions_real_get_preferred_width;
	((GtkWidgetClass *) klass)->draw = panel_window_entry_descriptions_real_draw;
	G_OBJECT_CLASS (klass)->get_property = _vala_panel_window_entry_descriptions_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_panel_window_entry_descriptions_set_property;
	G_OBJECT_CLASS (klass)->finalize = panel_window_entry_descriptions_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANEL_WINDOW_ENTRY_DESCRIPTIONS_OFFSET, g_param_spec_double ("offset", "offset", "offset", -G_MAXDOUBLE, G_MAXDOUBLE, (gdouble) 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void panel_window_entry_descriptions_instance_init (PanelWindowEntryDescriptions * self) {
	self->priv = PANEL_WINDOW_ENTRY_DESCRIPTIONS_GET_PRIVATE (self);
	self->priv->active_entry = NULL;
	self->priv->old_entry = NULL;
	self->priv->hiding = FALSE;
	self->priv->_offset = (gdouble) 0;
}


static void panel_window_entry_descriptions_finalize (GObject* obj) {
	PanelWindowEntryDescriptions * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, PanelWindowEntryDescriptions);
	_g_object_unref0 (self->priv->stack);
	_g_object_unref0 (self->priv->position_map);
	_g_object_unref0 (self->priv->pango);
	_animated_property_unref0 (self->priv->anim);
	G_OBJECT_CLASS (panel_window_entry_descriptions_parent_class)->finalize (obj);
}


GType panel_window_entry_descriptions_get_type (void) {
	static volatile gsize panel_window_entry_descriptions_type_id__volatile = 0;
	if (g_once_init_enter (&panel_window_entry_descriptions_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelWindowEntryDescriptionsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_window_entry_descriptions_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelWindowEntryDescriptions), 0, (GInstanceInitFunc) panel_window_entry_descriptions_instance_init, NULL };
		GType panel_window_entry_descriptions_type_id;
		panel_window_entry_descriptions_type_id = g_type_register_static (TYPE_PANEL_ABSTRACT_WINDOW, "PanelWindowEntryDescriptions", &g_define_type_info, 0);
		g_once_init_leave (&panel_window_entry_descriptions_type_id__volatile, panel_window_entry_descriptions_type_id);
	}
	return panel_window_entry_descriptions_type_id__volatile;
}


static void _vala_panel_window_entry_descriptions_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	PanelWindowEntryDescriptions * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, PanelWindowEntryDescriptions);
	switch (property_id) {
		case PANEL_WINDOW_ENTRY_DESCRIPTIONS_OFFSET:
		g_value_set_double (value, panel_window_entry_descriptions_get_offset (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_panel_window_entry_descriptions_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	PanelWindowEntryDescriptions * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_PANEL_WINDOW_ENTRY_DESCRIPTIONS, PanelWindowEntryDescriptions);
	switch (property_id) {
		case PANEL_WINDOW_ENTRY_DESCRIPTIONS_OFFSET:
		panel_window_entry_descriptions_set_offset (self, g_value_get_double (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


gboolean panel_window_host_no_windows_around (PanelWindowHost* self) {
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	panel_window_host_update (self, FALSE);
	_tmp0_ = self->priv->num_visible_windows;
	result = _tmp0_ == 0;
	return result;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		PanelWindowHost* self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->pager_entry);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static void __lambda48_ (PanelWindowHost* self) {
	gtk_widget_queue_resize ((GtkWidget*) self);
	panel_window_host_reposition (self);
}


static void ___lambda48__panel_abstract_window_screen_size_changed (PanelAbstractWindow* _sender, gpointer self) {
	__lambda48_ ((PanelWindowHost*) self);
}


static void ___lambda50_ (PanelWindowHost* self) {
	panel_window_host_update (self, TRUE);
}


static void ____lambda50__wnck_window_workspace_changed (WnckWindow* _sender, gpointer self) {
	___lambda50_ ((PanelWindowHost*) self);
}


static void __lambda49_ (PanelWindowHost* self, WnckWindow* w) {
	WnckWindow* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	WnckWindow* _tmp5_ = NULL;
	WnckWindowType _tmp6_ = 0;
	g_return_if_fail (w != NULL);
	_tmp0_ = w;
	_tmp1_ = wnck_window_is_skip_tasklist (_tmp0_);
	if (!_tmp1_) {
		WnckWindow* _tmp2_ = NULL;
		guint32 _tmp3_ = 0U;
		WnckWindow* _tmp4_ = NULL;
		_tmp2_ = w;
		_tmp3_ = gtk_get_current_event_time ();
		wnck_window_activate (_tmp2_, _tmp3_);
		panel_window_host_update (self, TRUE);
		_tmp4_ = w;
		g_signal_connect_object (_tmp4_, "workspace-changed", (GCallback) ____lambda50__wnck_window_workspace_changed, self, 0);
	}
	_tmp5_ = w;
	_tmp6_ = wnck_window_get_window_type (_tmp5_);
	if (_tmp6_ == WNCK_WINDOW_DIALOG) {
		g_signal_emit_by_name (self, "dialog-opened");
	}
}


static void ___lambda49__wnck_screen_window_opened (WnckScreen* _sender, WnckWindow* window, gpointer self) {
	__lambda49_ ((PanelWindowHost*) self, window);
}


static void __lambda51_ (PanelWindowHost* self, WnckWindow* w) {
	PanelWindowEntry* e = NULL;
	GeeHashMap* _tmp0_ = NULL;
	WnckWindow* _tmp1_ = NULL;
	gpointer _tmp2_ = NULL;
	PanelWindowEntry* _tmp3_ = NULL;
	PanelWindowEntry* _tmp4_ = NULL;
	g_return_if_fail (w != NULL);
	_tmp0_ = self->priv->entry_map;
	_tmp1_ = w;
	_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp0_, _tmp1_);
	_tmp3_ = _g_object_ref0 ((PanelWindowEntry*) _tmp2_);
	e = _tmp3_;
	_tmp4_ = e;
	if (_tmp4_ != NULL) {
		PanelWindowEntryDescriptions* _tmp5_ = NULL;
		PanelWindowEntry* _tmp6_ = NULL;
		PanelWindowEntry* _tmp7_ = NULL;
		GeeHashMap* _tmp8_ = NULL;
		WnckWindow* _tmp9_ = NULL;
		_tmp5_ = self->priv->descriptions;
		_tmp6_ = e;
		panel_window_entry_descriptions_clear_entry (_tmp5_, _tmp6_);
		_tmp7_ = e;
		gtk_widget_destroy ((GtkWidget*) _tmp7_);
		_tmp8_ = self->priv->entry_map;
		_tmp9_ = w;
		gee_abstract_map_unset ((GeeAbstractMap*) _tmp8_, _tmp9_, NULL);
		panel_window_host_update (self, FALSE);
	}
	_g_object_unref0 (e);
}


static void ___lambda51__wnck_screen_window_closed (WnckScreen* _sender, WnckWindow* window, gpointer self) {
	__lambda51_ ((PanelWindowHost*) self, window);
}


static void __lambda52_ (PanelWindowHost* self) {
	{
		GeeIterator* _e_it = NULL;
		GeeHashMap* _tmp0_ = NULL;
		GeeCollection* _tmp1_ = NULL;
		GeeCollection* _tmp2_ = NULL;
		GeeCollection* _tmp3_ = NULL;
		GeeIterator* _tmp4_ = NULL;
		GeeIterator* _tmp5_ = NULL;
		_tmp0_ = self->priv->entry_map;
		_tmp1_ = gee_abstract_map_get_values ((GeeMap*) _tmp0_);
		_tmp2_ = _tmp1_;
		_tmp3_ = _tmp2_;
		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
		_tmp5_ = _tmp4_;
		_g_object_unref0 (_tmp3_);
		_e_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_ = NULL;
			gboolean _tmp7_ = FALSE;
			PanelWindowEntry* e = NULL;
			GeeIterator* _tmp8_ = NULL;
			gpointer _tmp9_ = NULL;
			PanelWindowEntry* _tmp10_ = NULL;
			PanelWindowEntry* _tmp11_ = NULL;
			_tmp6_ = _e_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _e_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			_tmp10_ = _g_object_ref0 ((PanelWindowEntry*) _tmp9_);
			e = _tmp10_;
			_tmp11_ = e;
			panel_window_entry_sync_window_states (_tmp11_);
			_g_object_unref0 (e);
		}
		_g_object_unref0 (_e_it);
	}
}


static void ___lambda52__wnck_screen_active_window_changed (WnckScreen* _sender, WnckWindow* previous_window, gpointer self) {
	__lambda52_ ((PanelWindowHost*) self);
}


static void __lambda53_ (PanelWindowHost* self) {
	panel_window_host_update (self, TRUE);
}


static void ___lambda53__wnck_screen_viewports_changed (WnckScreen* _sender, gpointer self) {
	__lambda53_ ((PanelWindowHost*) self);
}


static void __lambda54_ (PanelWindowHost* self) {
	panel_window_host_update (self, TRUE);
}


static void ___lambda54__wnck_screen_active_workspace_changed (WnckScreen* _sender, WnckWorkspace* previous_workspace, gpointer self) {
	__lambda54_ ((PanelWindowHost*) self);
}


static gboolean __lambda55_ (PanelWindowHost* self) {
	gboolean result = FALSE;
	g_signal_emit_by_name (self, "activated");
	result = FALSE;
	return result;
}


static gboolean ___lambda55__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = __lambda55_ ((PanelWindowHost*) self);
	return result;
}


static void __lambda56_ (Block2Data* _data2_) {
	PanelWindowHost* self;
	self = _data2_->self;
	panel_window_pager_entry_reset_show_desktop (_data2_->pager_entry);
}


static void ___lambda56__panel_window_host_all_windows_visible (PanelWindowHost* _sender, gpointer self) {
	__lambda56_ (self);
}


static gboolean __lambda57_ (PanelWindowHost* self) {
	gboolean result = FALSE;
	panel_abstract_window_set_struts ((PanelAbstractWindow*) self);
	result = FALSE;
	return result;
}


static gboolean ___lambda57__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = __lambda57_ ((PanelWindowHost*) self);
	return result;
}


static gboolean __lambda58_ (PanelWindowHost* self) {
	gboolean result = FALSE;
	g_signal_emit_by_name (self, "menu-clicked");
	result = FALSE;
	return result;
}


static gboolean ___lambda58__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda58_ ((PanelWindowHost*) self);
	return result;
}


static gboolean __lambda59_ (PanelWindowHost* self) {
	gboolean result = FALSE;
	PanelCalendar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	_tmp0_ = self->priv->calendar;
	_tmp1_ = gtk_widget_get_visible ((GtkWidget*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		PanelCalendar* _tmp3_ = NULL;
		_tmp3_ = self->priv->calendar;
		gtk_widget_hide ((GtkWidget*) _tmp3_);
	} else {
		PanelCalendar* _tmp4_ = NULL;
		_tmp4_ = self->priv->calendar;
		gtk_widget_show_all ((GtkWidget*) _tmp4_);
	}
	result = TRUE;
	return result;
}


static gboolean ___lambda59__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda59_ ((PanelWindowHost*) self);
	return result;
}


PanelWindowHost* panel_window_host_construct (GType object_type) {
	PanelWindowHost * self = NULL;
	Block2Data* _data2_;
	GtkImage* _tmp0_ = NULL;
	GtkEventBox* event_box = NULL;
	GtkEventBox* _tmp1_ = NULL;
	GtkImage* _tmp2_ = NULL;
	GtkImage* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	GeeHashMap* _tmp5_ = NULL;
	PanelTray* _tmp6_ = NULL;
	PanelTray* _tmp7_ = NULL;
	WnckScreen* _tmp8_ = NULL;
	WnckScreen* _tmp9_ = NULL;
	GtkHBox* outer_box = NULL;
	GtkHBox* _tmp10_ = NULL;
	GtkHBox* _tmp11_ = NULL;
	PanelWindowPagerEntry* _tmp12_ = NULL;
	GeeHashMap* _tmp13_ = NULL;
	PanelWindowEntryDescriptions* _tmp14_ = NULL;
	PanelWindowEntryDescriptions* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	PanelClock* clock = NULL;
	PanelClock* _tmp17_ = NULL;
	GtkAlignment* a = NULL;
	GtkAlignment* _tmp18_ = NULL;
	GtkEventBox* clock_event = NULL;
	GtkEventBox* _tmp19_ = NULL;
	PanelCalendar* _tmp20_ = NULL;
	PanelCalendar* _tmp21_ = NULL;
	gint _tmp22_ = 0;
	PanelCalendar* _tmp23_ = NULL;
	PanelTray* _tmp24_ = NULL;
	GtkHBox* _tmp25_ = NULL;
	GtkHBox* _tmp26_ = NULL;
	WnckScreen* _tmp27_ = NULL;
	WnckScreen* _tmp28_ = NULL;
	WnckScreen* _tmp29_ = NULL;
	WnckScreen* _tmp30_ = NULL;
	WnckScreen* _tmp31_ = NULL;
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	self = (PanelWindowHost*) panel_abstract_window_construct (object_type);
	_data2_->self = g_object_ref (self);
	_tmp0_ = (GtkImage*) gtk_image_new_from_icon_name ("distributor-logo", GTK_ICON_SIZE_LARGE_TOOLBAR);
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->logo);
	self->priv->logo = _tmp0_;
	_tmp1_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp1_);
	event_box = _tmp1_;
	_tmp2_ = self->priv->logo;
	gtk_container_add ((GtkContainer*) event_box, (GtkWidget*) _tmp2_);
	gtk_widget_show_all ((GtkWidget*) event_box);
	_tmp3_ = self->priv->logo;
	_tmp4_ = self->priv->height;
	gtk_image_set_pixel_size (_tmp3_, _tmp4_);
	_tmp5_ = gee_hash_map_new (WNCK_TYPE_WINDOW, (GBoxedCopyFunc) g_object_ref, g_object_unref, TYPE_PANEL_WINDOW_ENTRY, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->entry_map);
	self->priv->entry_map = _tmp5_;
	_tmp6_ = panel_tray_new ();
	g_object_ref_sink (_tmp6_);
	_g_object_unref0 (self->priv->tray);
	self->priv->tray = _tmp6_;
	_tmp7_ = self->priv->tray;
	gtk_widget_show ((GtkWidget*) _tmp7_);
	self->priv->num_visible_windows = 0;
	gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_DOCK);
	self->priv->active = FALSE;
	_tmp8_ = wnck_screen_get_default ();
	_tmp9_ = _g_object_ref0 (_tmp8_);
	_g_object_unref0 (self->priv->screen);
	self->priv->screen = _tmp9_;
	_tmp10_ = (GtkHBox*) gtk_hbox_new (FALSE, 0);
	g_object_ref_sink (_tmp10_);
	outer_box = _tmp10_;
	_tmp11_ = (GtkHBox*) gtk_hbox_new (TRUE, 0);
	g_object_ref_sink (_tmp11_);
	_g_object_unref0 (self->priv->box);
	self->priv->box = _tmp11_;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) outer_box);
	_tmp12_ = panel_window_pager_entry_new ();
	g_object_ref_sink (_tmp12_);
	_data2_->pager_entry = _tmp12_;
	gtk_buildable_set_name ((GtkBuildable*) _data2_->pager_entry, "PAGER");
	gtk_widget_show ((GtkWidget*) _data2_->pager_entry);
	_tmp13_ = self->priv->entry_map;
	_tmp14_ = panel_window_entry_descriptions_new (_tmp13_);
	g_object_ref_sink (_tmp14_);
	_g_object_unref0 (self->priv->descriptions);
	self->priv->descriptions = _tmp14_;
	_tmp15_ = self->priv->descriptions;
	_tmp16_ = self->priv->height;
	panel_window_entry_descriptions_update_position (_tmp15_, _tmp16_);
	_tmp17_ = panel_clock_new ();
	g_object_ref_sink (_tmp17_);
	clock = _tmp17_;
	gtk_widget_show ((GtkWidget*) clock);
	_tmp18_ = (GtkAlignment*) gtk_alignment_new ((gfloat) 0, 0.5f, (gfloat) 0, (gfloat) 0);
	g_object_ref_sink (_tmp18_);
	a = _tmp18_;
	gtk_container_add ((GtkContainer*) a, (GtkWidget*) clock);
	gtk_widget_show ((GtkWidget*) a);
	_tmp19_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp19_);
	clock_event = _tmp19_;
	gtk_widget_show_all ((GtkWidget*) clock_event);
	gtk_container_add ((GtkContainer*) clock_event, (GtkWidget*) a);
	_tmp20_ = panel_calendar_new ();
	g_object_ref_sink (_tmp20_);
	_g_object_unref0 (self->priv->calendar);
	self->priv->calendar = _tmp20_;
	_tmp21_ = self->priv->calendar;
	_tmp22_ = self->priv->height;
	panel_calendar_update_position (_tmp21_, _tmp22_);
	_tmp23_ = self->priv->calendar;
	gtk_widget_hide ((GtkWidget*) _tmp23_);
	gtk_box_pack_end ((GtkBox*) outer_box, (GtkWidget*) _data2_->pager_entry, FALSE, FALSE, (guint) 1);
	gtk_box_pack_end ((GtkBox*) outer_box, (GtkWidget*) clock_event, FALSE, FALSE, (guint) 0);
	_tmp24_ = self->priv->tray;
	gtk_box_pack_end ((GtkBox*) outer_box, (GtkWidget*) _tmp24_, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) outer_box, (GtkWidget*) event_box, FALSE, FALSE, (guint) 0);
	_tmp25_ = self->priv->box;
	gtk_box_pack_start ((GtkBox*) outer_box, (GtkWidget*) _tmp25_, FALSE, FALSE, (guint) 0);
	gtk_widget_show ((GtkWidget*) outer_box);
	_tmp26_ = self->priv->box;
	gtk_widget_show ((GtkWidget*) _tmp26_);
	gtk_widget_show ((GtkWidget*) self);
	panel_window_host_reposition (self);
	panel_abstract_window_set_struts ((PanelAbstractWindow*) self);
	g_signal_connect_object ((PanelAbstractWindow*) self, "screen-size-changed", (GCallback) ___lambda48__panel_abstract_window_screen_size_changed, self, 0);
	_tmp27_ = self->priv->screen;
	g_signal_connect_object (_tmp27_, "window-opened", (GCallback) ___lambda49__wnck_screen_window_opened, self, 0);
	_tmp28_ = self->priv->screen;
	g_signal_connect_object (_tmp28_, "window-closed", (GCallback) ___lambda51__wnck_screen_window_closed, self, 0);
	_tmp29_ = self->priv->screen;
	g_signal_connect_object (_tmp29_, "active-window-changed", (GCallback) ___lambda52__wnck_screen_active_window_changed, self, 0);
	_tmp30_ = self->priv->screen;
	g_signal_connect_object (_tmp30_, "viewports-changed", (GCallback) ___lambda53__wnck_screen_viewports_changed, self, 0);
	_tmp31_ = self->priv->screen;
	g_signal_connect_object (_tmp31_, "active-workspace-changed", (GCallback) ___lambda54__wnck_screen_active_workspace_changed, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "enter-notify-event", (GCallback) ___lambda55__gtk_widget_enter_notify_event, self, 0);
	g_signal_connect_data (self, "all-windows-visible", (GCallback) ___lambda56__panel_window_host_all_windows_visible, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	g_signal_connect_object ((GtkWidget*) self, "configure-event", (GCallback) ___lambda57__gtk_widget_configure_event, self, 0);
	g_signal_connect_object ((GtkWidget*) event_box, "button-press-event", (GCallback) ___lambda58__gtk_widget_button_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) clock_event, "button-release-event", (GCallback) ___lambda59__gtk_widget_button_release_event, self, 0);
	_g_object_unref0 (clock_event);
	_g_object_unref0 (a);
	_g_object_unref0 (clock);
	_g_object_unref0 (outer_box);
	_g_object_unref0 (event_box);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return self;
}


PanelWindowHost* panel_window_host_new (void) {
	return panel_window_host_construct (TYPE_PANEL_WINDOW_HOST);
}


static void panel_window_host_real_get_preferred_width (GtkWidget* base, gint* min, gint* max) {
	PanelWindowHost * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	gint r = 0;
	GdkRectangle _tmp0_ = {0};
	gint _tmp1_ = 0;
	self = (PanelWindowHost*) base;
	panel_screen_get_primary_monitor_geometry (&_tmp0_);
	_tmp1_ = _tmp0_.width;
	r = _tmp1_;
	_vala_max = r;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static void panel_window_host_real_get_preferred_height (GtkWidget* base, gint* min, gint* max) {
	PanelWindowHost * self;
	gint _vala_min = 0;
	gint _vala_max = 0;
	gint _tmp0_ = 0;
	self = (PanelWindowHost*) base;
	_tmp0_ = self->priv->height;
	_vala_max = _tmp0_;
	_vala_min = _vala_max;
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		PanelWindowHost* self;
		self = _data3_->self;
		_g_object_unref0 (_data3_->e);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static void ______lambda42_ (Block3Data* _data3_) {
	PanelWindowHost* self;
	PanelWindowEntryDescriptions* _tmp0_ = NULL;
	PanelWindowEntry* _tmp1_ = NULL;
	self = _data3_->self;
	_tmp0_ = self->priv->descriptions;
	_tmp1_ = _data3_->e;
	panel_window_entry_descriptions_activate (_tmp0_, _tmp1_);
}


static void _______lambda42__panel_window_entry_entered (PanelWindowEntry* _sender, gpointer self) {
	______lambda42_ (self);
}


static void ______lambda43_ (PanelWindowHost* self) {
	PanelWindowEntryDescriptions* _tmp0_ = NULL;
	_tmp0_ = self->priv->descriptions;
	panel_window_entry_descriptions_deactivate (_tmp0_);
}


static void _______lambda43__panel_window_entry_left (PanelWindowEntry* _sender, gpointer self) {
	______lambda43_ ((PanelWindowHost*) self);
}


void panel_window_host_update (PanelWindowHost* self, gboolean emit_change_signals) {
	GtkHBox* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	WnckWorkspace* workspace = NULL;
	WnckScreen* _tmp5_ = NULL;
	WnckWorkspace* _tmp6_ = NULL;
	WnckWorkspace* _tmp7_ = NULL;
	WnckWorkspace* _tmp8_ = NULL;
	gint num_total_windows = 0;
	gint num_windows = 0;
	WnckScreen* _tmp9_ = NULL;
	GList* _tmp10_ = NULL;
	gboolean _tmp52_ = FALSE;
	gint _tmp56_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->box;
	_tmp1_ = gtk_container_get_children ((GtkContainer*) _tmp0_);
	{
		GList* w_collection = NULL;
		GList* w_it = NULL;
		w_collection = _tmp1_;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			GtkWidget* w = NULL;
			w = (GtkWidget*) w_it->data;
			{
				GtkWidget* _tmp2_ = NULL;
				_tmp2_ = w;
				if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, TYPE_PANEL_WINDOW_ENTRY)) {
					GtkHBox* _tmp3_ = NULL;
					GtkWidget* _tmp4_ = NULL;
					_tmp3_ = self->priv->box;
					_tmp4_ = w;
					gtk_container_remove ((GtkContainer*) _tmp3_, _tmp4_);
				}
			}
		}
		_g_list_free0 (w_collection);
	}
	_tmp5_ = self->priv->screen;
	_tmp6_ = wnck_screen_get_active_workspace (_tmp5_);
	_tmp7_ = _g_object_ref0 (_tmp6_);
	workspace = _tmp7_;
	_tmp8_ = workspace;
	if (_tmp8_ == NULL) {
		_g_object_unref0 (workspace);
		return;
	}
	num_total_windows = 0;
	num_windows = 0;
	_tmp9_ = self->priv->screen;
	_tmp10_ = wnck_screen_get_windows (_tmp9_);
	{
		GList* w_collection = NULL;
		GList* w_it = NULL;
		w_collection = _tmp10_;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			WnckWindow* w = NULL;
			w = (WnckWindow*) w_it->data;
			{
				gboolean _tmp11_ = FALSE;
				gboolean _tmp12_ = FALSE;
				WnckWindow* _tmp13_ = NULL;
				gboolean _tmp14_ = FALSE;
				_tmp13_ = w;
				_tmp14_ = wnck_window_is_skip_tasklist (_tmp13_);
				if (!_tmp14_) {
					WnckWindow* _tmp15_ = NULL;
					const gchar* _tmp16_ = NULL;
					_tmp15_ = w;
					_tmp16_ = wnck_window_get_name (_tmp15_);
					_tmp12_ = g_strcmp0 (_tmp16_, "_manokwari_menu_") != 0;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					WnckWindow* _tmp17_ = NULL;
					WnckWorkspace* _tmp18_ = NULL;
					gboolean _tmp19_ = FALSE;
					_tmp17_ = w;
					_tmp18_ = workspace;
					_tmp19_ = wnck_window_is_on_workspace (_tmp17_, _tmp18_);
					_tmp11_ = _tmp19_;
				} else {
					_tmp11_ = FALSE;
				}
				if (_tmp11_) {
					Block3Data* _data3_;
					GeeHashMap* _tmp20_ = NULL;
					WnckWindow* _tmp21_ = NULL;
					gpointer _tmp22_ = NULL;
					PanelWindowEntry* _tmp23_ = NULL;
					PanelWindowEntry* _tmp24_ = NULL;
					WnckWindow* _tmp32_ = NULL;
					gboolean _tmp33_ = FALSE;
					gint _tmp35_ = 0;
					_data3_ = g_slice_new0 (Block3Data);
					_data3_->_ref_count_ = 1;
					_data3_->self = g_object_ref (self);
					_tmp20_ = self->priv->entry_map;
					_tmp21_ = w;
					_tmp22_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp20_, _tmp21_);
					_tmp23_ = _g_object_ref0 ((PanelWindowEntry*) _tmp22_);
					_data3_->e = _tmp23_;
					_tmp24_ = _data3_->e;
					if (_tmp24_ == NULL) {
						WnckWindow* _tmp25_ = NULL;
						PanelWindowEntry* _tmp26_ = NULL;
						GeeHashMap* _tmp27_ = NULL;
						WnckWindow* _tmp28_ = NULL;
						PanelWindowEntry* _tmp29_ = NULL;
						PanelWindowEntry* _tmp30_ = NULL;
						PanelWindowEntry* _tmp31_ = NULL;
						_tmp25_ = w;
						_tmp26_ = panel_window_entry_new (_tmp25_);
						g_object_ref_sink (_tmp26_);
						_g_object_unref0 (_data3_->e);
						_data3_->e = _tmp26_;
						_tmp27_ = self->priv->entry_map;
						_tmp28_ = w;
						_tmp29_ = _data3_->e;
						gee_abstract_map_set ((GeeAbstractMap*) _tmp27_, _tmp28_, _tmp29_);
						_tmp30_ = _data3_->e;
						g_signal_connect_data (_tmp30_, "entered", (GCallback) _______lambda42__panel_window_entry_entered, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
						_tmp31_ = _data3_->e;
						g_signal_connect_object (_tmp31_, "left", (GCallback) _______lambda43__panel_window_entry_left, self, 0);
					}
					_tmp32_ = w;
					_tmp33_ = wnck_window_is_minimized (_tmp32_);
					if (!_tmp33_) {
						gint _tmp34_ = 0;
						_tmp34_ = num_windows;
						num_windows = _tmp34_ + 1;
					}
					_tmp35_ = num_total_windows;
					num_total_windows = _tmp35_ + 1;
					block3_data_unref (_data3_);
					_data3_ = NULL;
				}
			}
		}
	}
	{
		GeeIterator* _e_it = NULL;
		GeeHashMap* _tmp36_ = NULL;
		GeeCollection* _tmp37_ = NULL;
		GeeCollection* _tmp38_ = NULL;
		GeeCollection* _tmp39_ = NULL;
		GeeIterator* _tmp40_ = NULL;
		GeeIterator* _tmp41_ = NULL;
		_tmp36_ = self->priv->entry_map;
		_tmp37_ = gee_abstract_map_get_values ((GeeMap*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = _tmp38_;
		_tmp40_ = gee_iterable_iterator ((GeeIterable*) _tmp39_);
		_tmp41_ = _tmp40_;
		_g_object_unref0 (_tmp39_);
		_e_it = _tmp41_;
		while (TRUE) {
			GeeIterator* _tmp42_ = NULL;
			gboolean _tmp43_ = FALSE;
			PanelWindowEntry* e = NULL;
			GeeIterator* _tmp44_ = NULL;
			gpointer _tmp45_ = NULL;
			PanelWindowEntry* _tmp46_ = NULL;
			PanelWindowEntry* _tmp47_ = NULL;
			gboolean _tmp48_ = FALSE;
			_tmp42_ = _e_it;
			_tmp43_ = gee_iterator_next (_tmp42_);
			if (!_tmp43_) {
				break;
			}
			_tmp44_ = _e_it;
			_tmp45_ = gee_iterator_get (_tmp44_);
			_tmp46_ = _g_object_ref0 ((PanelWindowEntry*) _tmp45_);
			e = _tmp46_;
			_tmp47_ = e;
			_tmp48_ = panel_window_entry_is_on_current_workspace (_tmp47_);
			if (_tmp48_) {
				PanelWindowEntry* _tmp49_ = NULL;
				GtkHBox* _tmp50_ = NULL;
				PanelWindowEntry* _tmp51_ = NULL;
				_tmp49_ = e;
				gtk_widget_show ((GtkWidget*) _tmp49_);
				_tmp50_ = self->priv->box;
				_tmp51_ = e;
				gtk_box_pack_start ((GtkBox*) _tmp50_, (GtkWidget*) _tmp51_, TRUE, TRUE, (guint) 0);
			}
			_g_object_unref0 (e);
		}
		_g_object_unref0 (_e_it);
	}
	_tmp52_ = emit_change_signals;
	if (_tmp52_) {
		gint _tmp53_ = 0;
		gint _tmp54_ = 0;
		gint _tmp55_ = 0;
		_tmp53_ = num_windows;
		if (_tmp53_ == 0) {
			g_signal_emit_by_name (self, "windows-gone");
		} else {
			g_signal_emit_by_name (self, "windows-visible");
		}
		_tmp54_ = num_windows;
		_tmp55_ = num_total_windows;
		if (_tmp54_ == _tmp55_) {
			g_signal_emit_by_name (self, "all-windows-visible");
		}
	}
	_tmp56_ = num_windows;
	self->priv->num_visible_windows = _tmp56_;
	_g_object_unref0 (workspace);
}


void panel_window_host_reposition (PanelWindowHost* self) {
	PanelWindowEntryDescriptions* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	PanelCalendar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	g_return_if_fail (self != NULL);
	panel_screen_move_window ((GtkWindow*) self, GDK_GRAVITY_NORTH_WEST);
	_tmp0_ = self->priv->descriptions;
	_tmp1_ = self->priv->height;
	panel_window_entry_descriptions_update_position (_tmp0_, _tmp1_);
	_tmp2_ = self->priv->calendar;
	_tmp3_ = self->priv->height;
	panel_calendar_update_position (_tmp2_, _tmp3_);
	gtk_window_set_keep_above ((GtkWindow*) self, FALSE);
}


static void panel_window_host_class_init (PanelWindowHostClass * klass) {
	panel_window_host_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PanelWindowHostPrivate));
	((GtkWidgetClass *) klass)->get_preferred_width = panel_window_host_real_get_preferred_width;
	((GtkWidgetClass *) klass)->get_preferred_height = panel_window_host_real_get_preferred_height;
	G_OBJECT_CLASS (klass)->finalize = panel_window_host_finalize;
	g_signal_new ("windows_gone", TYPE_PANEL_WINDOW_HOST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("windows_visible", TYPE_PANEL_WINDOW_HOST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("all_windows_visible", TYPE_PANEL_WINDOW_HOST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("dialog_opened", TYPE_PANEL_WINDOW_HOST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("menu_clicked", TYPE_PANEL_WINDOW_HOST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("activated", TYPE_PANEL_WINDOW_HOST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void panel_window_host_instance_init (PanelWindowHost * self) {
	self->priv = PANEL_WINDOW_HOST_GET_PRIVATE (self);
	self->priv->num_visible_windows = 0;
	self->priv->height = 24;
}


static void panel_window_host_finalize (GObject* obj) {
	PanelWindowHost * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANEL_WINDOW_HOST, PanelWindowHost);
	_g_object_unref0 (self->priv->logo);
	_g_object_unref0 (self->priv->box);
	_g_object_unref0 (self->priv->tray);
	_g_object_unref0 (self->priv->screen);
	_g_object_unref0 (self->priv->entry_map);
	_g_object_unref0 (self->priv->descriptions);
	_g_object_unref0 (self->priv->calendar);
	G_OBJECT_CLASS (panel_window_host_parent_class)->finalize (obj);
}


GType panel_window_host_get_type (void) {
	static volatile gsize panel_window_host_type_id__volatile = 0;
	if (g_once_init_enter (&panel_window_host_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PanelWindowHostClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_window_host_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PanelWindowHost), 0, (GInstanceInitFunc) panel_window_host_instance_init, NULL };
		GType panel_window_host_type_id;
		panel_window_host_type_id = g_type_register_static (TYPE_PANEL_ABSTRACT_WINDOW, "PanelWindowHost", &g_define_type_info, 0);
		g_once_init_leave (&panel_window_host_type_id__volatile, panel_window_host_type_id);
	}
	return panel_window_host_type_id__volatile;
}



